<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>勇敢的心</title>
    <link>https://Hack1ng4fun.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Just for Fun</description>
    <pubDate>Fri, 29 May 2020 04:10:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Linux 下使用「裸」Tor</title>
      <link>https://hack1ng4fun.github.io/2020/05/29/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8%E3%80%8C%E8%A3%B8%E3%80%8DTor/</link>
      <guid>https://hack1ng4fun.github.io/2020/05/29/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8%E3%80%8C%E8%A3%B8%E3%80%8DTor/</guid>
      <pubDate>Fri, 29 May 2020 04:10:22 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Linux下使用「裸」Tor&quot;&gt;&lt;a href=&quot;#Linux下使用「裸」Tor&quot; class=&quot;headerlink&quot; title=&quot;Linux下使用「裸」Tor&quot;&gt;&lt;/a&gt;Linux下使用「裸」Tor&lt;/h1&gt;&lt;h2 id=&quot;TOR-简介&quot;&gt;&lt;a href=&quot;#TOR-简介&quot; class=&quot;headerlink&quot; title=&quot;TOR 简介&quot;&gt;&lt;/a&gt;TOR 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Tor 是实现匿名通信的自由软件。其名源于「The Onion Router」（洋葱路由器）的英语缩写。用戶可通过 Tor 连接由全球志愿者免费提供，包含 7000+ 个中继的覆盖网络，从而达到隐藏用戶真实地址、避免网络监控及流量分析的目的。Tor 用戶的互联网活动（包括浏览在线网站、帖子以及即时消息等通讯形式）相对较难追踪。Tor 的设计初衷在于保障用戶的个人隐私，以及不受监控地进行秘密通信的自由和能力。  ——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Linux下使用「裸」Tor"><a href="#Linux下使用「裸」Tor" class="headerlink" title="Linux下使用「裸」Tor"></a>Linux下使用「裸」Tor</h1><h2 id="TOR-简介"><a href="#TOR-简介" class="headerlink" title="TOR 简介"></a>TOR 简介</h2><blockquote><p>Tor 是实现匿名通信的自由软件。其名源于「The Onion Router」（洋葱路由器）的英语缩写。用戶可通过 Tor 连接由全球志愿者免费提供，包含 7000+ 个中继的覆盖网络，从而达到隐藏用戶真实地址、避免网络监控及流量分析的目的。Tor 用戶的互联网活动（包括浏览在线网站、帖子以及即时消息等通讯形式）相对较难追踪。Tor 的设计初衷在于保障用戶的个人隐私，以及不受监控地进行秘密通信的自由和能力。  ——维基百科</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到标题有些人可能会有疑问，“为什么说是「裸」Tor 呢？”，因为这里说的 Tor 和有些人认为的 Tor 不同。使用 Tor 的大部分用户其实使用的是「Tor Browser」，这是一个「Tor 套件」，它包含了为 Tor 用户特别定制的 Firefox 浏览器（增强了隐私保护以及自带了一些安全拓展等），通过「Tor Browser」，用户可以简单地通过图形界面来启动 Tor，降低了使用门槛。而本文采用的是「不带 Firefox 的单独 Tor」，所以称之为「裸 Tor」。</p><p>「Tor Browser」对不精于技术但想保护自己隐私的普通用户来说无疑是非常友好的，但对于我这种「喜欢折腾」的技术宅来说，更希望能够保持精简与高度自定义。鉴于这是一篇「新手友好」的文章，内容不会太深入，主要介绍 Tor 在 Linux 下的基本配置与使用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>主流发行版都有 Tor 的软件包，根据你使用的发行版参照官方 Wiki 进行安装，这部份通常都很简单——几行命令的事，这里我用 Arch Linux 示范安装：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/fof9.png" alt="安装 Tor"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装成功后可以通过启动 <code>tor</code> 服务来启动/停止 Tor，在国内网络环境下，直接启动显然是无法成功连接的——Tor 节点早已被国内封锁，启动前需要先配置一个「前置代理」来帮助连接到 Tor 网络，打开配置文件<code>/etc/tor/torrc</code>（在不同发行版，Tor 的配置文件位置可能不一样，如果配置文件不在这个位置请参考发行版的官方 Wiki 或自行上网搜索），在<code>torrc</code>中添加以下配置指定一个前置代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Socks5Proxy 127.0.0.1:6666 <span class="hljs-comment"># 代理地址根据你自己的代理填写</span><br></code></pre></td></tr></table></figure><p>默认情况下，Tor 的 Socks 代理会监听 9050 端口，可以通过<code>torrc</code>中的<code>SocksPort</code>字段修改：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/aa.png" alt="SocksPort 字段"></p><p>Tor 另外还提供了一个「控制端口」，让「控制器应用」（后面会介绍）能够通过此端口访问到 Tor 的内部，用来监控 Tor 的网络流量、运行日志等，以及其他控制功能。「控制端口」的默认监听端口是 9051，可以通过<code>ControlPort</code>字段修改：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20200529012925.png" alt="ControlPort 字段"></p><p>Tor 的节点都是由志愿者提供，其中自然也可能存在「不怀好意」的节点，比如一些国家机构为了打破 Tor 的匿名性，部署了不定数量的「蜜罐节点」。虽然 Tor 的节点都是随机分配的（并且每隔一段时间就会改变线路），但是也要保持警惕（运气是不可靠的），特别是天朝，「身在天朝」的人不可能对这种威胁视而不见。好在可以通过 Tor 的一些配置缓解（不是解决）以上问题，以降低「蜜罐节点」的威胁，通过<code>ExcludeNodes</code>字段指定 Tor 不要使用来自哪些国家的节点（天朝一定要排除，和天朝「关系暧昧」的国家也建议排除！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ExcludeNodes &#123;cn&#125;,&#123;hk&#125;,&#123;mo&#125;<br></code></pre></td></tr></table></figure><p>开启<code>StrictNodes</code>选项（即使没有节点可用时也不会去尝试<code>ExcludeNodes</code>选项排除的节点，这个选项不开启的话，如果没有节点可用时，Tor 就会去尝试排除的节点，这是危险的！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">StrictNodes 1<br></code></pre></td></tr></table></figure><p>如果希望其他设备（在同一局域网内）也能够使用 PC 上运行的 Tor 的话，可以再添加一个<code>SocksPort</code>监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">SocksPort 192.168.1.5:10240 <span class="hljs-comment"># 本机的 IP 地址和要监听的端口</span><br></code></pre></td></tr></table></figure><p>这样在同一局域网内的其他设备就能通过<code>192.168.1.5:10240</code>这个地址来连接 Tor 的 Socks 代理。</p><p>关于 Tor 的配置，还有很多其他的选项，比如限制 IP/端口 访问等……这里不多介绍了，需要的请到<a href="https://2019.www.torproject.org/docs/tor-manual.html.en" target="_blank" rel="noopener">这里</a>了解。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>配置好以后，启动 Tor 服务：<code>systemctl start tor</code>，查看 Tor 启动状态：<code>systemctl status tor</code>，如果 Tor 配置 和 「前置代理」都没问题的话，就能看到 Tor 已经 100% 启动：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/Screenshot_20200529_040003.png" alt="Tor 启动"></p><p>现在来测试一下是否成功连接到了 Tor 网络，根据前面自己配置的代理端口（没配置的话默认是 9050）设置浏览器代理，我这里使用 Firefox 的 SwitchyOmega 拓展新建一个代理（直接在浏览器中设置也可以），配置如下：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/Screenshot_20200529_042021.png" alt="Tor 代理"></p><p>配置好代理后，访问 Tor 官方的<a href="https://check.torproject.org/" target="_blank" rel="noopener">检查页面</a>：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/Screenshot_20200529_042601.png" alt="Tor 检查"></p><p>可以看到已经成功连接到了 Tor 网络，如果其他程序想要使用 Tor 代理，只需要配置程序的代理设置为 Tor 代理即可；如果程序不支持使用代理，那么可以尝试使用 <a href="https://github.com/haad/proxychains" target="_blank" rel="noopener">ProxyChains</a>。</p><h2 id="Nyx"><a href="#Nyx" class="headerlink" title="Nyx"></a>Nyx</h2><p>想要检查 Tor 的运行状态和网络流量等信息，可以使用官方推荐的<a href="https://nyx.torproject.org/" target="_blank" rel="noopener">Nyx</a>工具。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Nyx 的安装和安装 Tor 一样简单，安装过程就不演示了，请自行参考官方 Wiki或网络教程。</p><h3 id="设置-Tor-访问密码"><a href="#设置-Tor-访问密码" class="headerlink" title="设置 Tor 访问密码"></a>设置 Tor 访问密码</h3><p>前面说过，Tor 提供了一个「控制端口」，实际上就是给 Nyx 这类工具使用的。为了安全起见，连接之前需要先给 Tor 的「控制端口」设置一个访问密码，<strong>不要使用配置文件默认的密码</strong>，使用以下命令生成密码 Hash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">tor --<span class="hljs-built_in">hash</span>-password <span class="hljs-string">"你要设置的密码"</span><br></code></pre></td></tr></table></figure><p>执行后会得到一个类似<code>16:3266B495ABCDE7BE60C427803A077AE9F913092837E0635DD4E28A344E</code>这样的字符串，把它复制一下，填入配置文件的<code>HashedControlPassword</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">HashedControlPassword 16:526AB953967827D5601A347283A93A78DBC9535EE60B7D25737375EC2C<br></code></pre></td></tr></table></figure><p>保存配置文件后重载 Tor 服务：<code>systemctl reload tor</code>。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行 Nyx：<code>nyx -i 8889</code>（8889 为 Tor 的控制端口，如果没有设置 Tor 的「控制端口」则不需要 <code>-i</code>参数），然后它会要求输入密码，正确输入你设置的密码后即可进入到界面：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/fill.png" alt="Nyx 界面"><br>由于涉及到隐私的关系，对显示日志的区域进行了模糊处理。</p><p>按方向键（左右）可以切换显示页面，总共有 5 页，每页的内容分别是网络流量+ Tor/Nyx 运行日志、网络连接、配置选项、原始配置文件、命令解释器；按<code>m</code>键可以显示顶级菜单栏，通过菜单栏里的选项可以获取新身份（New Identity）；按<code>h</code>键显示当前页面的快捷键……</p><p>这个工具虽然是命令行界面的，但是却非常的简单易用，关于此工具的具体用法请自己体验。</p><h2 id="Snowflake"><a href="#Snowflake" class="headerlink" title="Snowflake"></a>Snowflake</h2><p>Tor 在 2019 年发布了新的「可插拔传输」（网桥）“Snowflake”，它使用 WebRTC 来代理通过临时代理的流量。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/snowflake-schematic.png" alt="Snowflake 流量走向示意图"></p><p>如果你所在的地区没有审查，你可以使用“Snowflake”帮助那些在审查网络中的人们，帮助他们捍卫自由与隐私；与此同时，你只需要安装一个浏览器拓展或仅仅是打开一个网站而已。</p><p>如果你想通过“Snowflake”帮助他人，有以下方法供你选择：</p><p><strong>开始前请确保你的浏览器启用了 WebRTC</strong></p><ul><li><p>浏览器拓展<br>安装<a href="https://addons.mozilla.org/en-US/firefox/addon/torproject-snowflake/" target="_blank" rel="noopener">Firefox拓展</a>或<a href="https://chrome.google.com/webstore/detail/snowflake/mafpmfcccpbjnhfhjnllmmalhifmlcie" target="_blank" rel="noopener">Chrome拓展</a>，这将使你成为“Snowflake”代理。它还可以告诉你在过去 24 小时内帮助了多少人。</p></li><li><p>浏览器<br>进入<a href="https://snowflake.torproject.org/embed" target="_blank" rel="noopener">这个网站</a>，点击按钮以启用“Snowflake”，同时你依然能够正常使用浏览器（如切换到其他页面），不要关闭页面就行。</p></li><li><p>独立（专业）</p><p>使用此方法你将需要安装和配置 Go 来构建独立的 proxy-go 代码，请参考<a href="https://trac.torproject.org/projects/tor/wiki/doc/Snowflake#Option3standalone" target="_blank" rel="noopener">官方文档</a>。</p></li></ul><h2 id="Tor-客户端"><a href="#Tor-客户端" class="headerlink" title="Tor 客户端"></a>Tor 客户端</h2><p>你在 Windows、Linux、macOS、Android、iOS 上都可以使用 Tor，在<a href="https://www.torproject.org/download/" target="_blank" rel="noopener">官网</a>可以下载到各个平台的客户端。</p><h2 id="使用-Tor-应当具备的安全意识"><a href="#使用-Tor-应当具备的安全意识" class="headerlink" title="使用 Tor 应当具备的安全意识"></a>使用 Tor 应当具备的安全意识</h2><ul><li><p>不要使用 Tor 登录日常使用的帐号</p></li><li><p>不要在任何地方透露自己的个人信息</p></li><li><p>不要访问使用 HTTP 协议的站点，只访问 HTTPS 站点</p></li><li><p>避免在 Tor 中进行的网络活动与外网相关联（访问同一台服务器、登录同一个帐号、使用同一个 ID、……）</p></li><li><p>使用「前置代理」连接到 Tor</p></li><li><p>对不信任的网站不要启用 JavaScript 脚本（使用 NoScript 拓展）</p></li><li><p>始终保持 Tor 的版本为最新</p></li><li><p>退出 Tor 时清除浏览器的历史记录、Cookie、本地存储等数据</p></li><li><p>在虚拟机中进行要求高安全性的活动，并使用保护隐私相关的 Linux 系统：</p><ul><li><a href="https://www.qubes-os.org/" target="_blank" rel="noopener">Qubes OS</a></li><li><a href="https://tails.boum.org/" target="_blank" rel="noopener">Tails</a></li><li><a href="http://www.ipredia.org/os/" target="_blank" rel="noopener">IprediaOS</a></li><li><a href="https://www.whonix.org/" target="_blank" rel="noopener">Whonix</a></li><li>……</li></ul></li><li><p>……</p></li></ul><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/alexander-popov-KtfPqWwhvOs-unsplash.jpg" alt=""></p><p>发布本文的初衷是为了给那些追求自由、捍卫隐私的人们一个小小的参考，如果你只是想以此掩盖自己不正义、不道德的犯罪活动，那你很卑劣哦。</p>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2020/05/29/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8%E3%80%8C%E8%A3%B8%E3%80%8DTor/#disqus_thread</comments>
    </item>
    
    <item>
      <title>WAF的一些绕过方法</title>
      <link>https://hack1ng4fun.github.io/2020/04/02/WAF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</link>
      <guid>https://hack1ng4fun.github.io/2020/04/02/WAF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Thu, 02 Apr 2020 11:37:23 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;WAF的一些绕过方法&quot;&gt;&lt;a href=&quot;#WAF的一些绕过方法&quot; class=&quot;headerlink&quot; title=&quot;WAF的一些绕过方法&quot;&gt;&lt;/a&gt;WAF的一些绕过方法&lt;/h1&gt;&lt;p&gt;WAF 全称为「Web应用防火墙」（Web Application Firewall），是网站常用来保护Web应用安全的一种安全产品。主要功能是通过检测客户端的请求内容，对具有潜在危险性的请求进行拦截，可以有效防御一些常见的针对 Web 应用的攻击（SQL注入、XSS、……）。&lt;/p&gt;
&lt;p&gt;现在的中、大型网站基本都部署了 WAF 产品，作为一名渗透测试人员，如果没有掌握 WAF 的基本绕过方法，在渗透测试过程中会举步维艰。本文列举了一些常见的 WAF 绕过方法。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="WAF的一些绕过方法"><a href="#WAF的一些绕过方法" class="headerlink" title="WAF的一些绕过方法"></a>WAF的一些绕过方法</h1><p>WAF 全称为「Web应用防火墙」（Web Application Firewall），是网站常用来保护Web应用安全的一种安全产品。主要功能是通过检测客户端的请求内容，对具有潜在危险性的请求进行拦截，可以有效防御一些常见的针对 Web 应用的攻击（SQL注入、XSS、……）。</p><p>现在的中、大型网站基本都部署了 WAF 产品，作为一名渗透测试人员，如果没有掌握 WAF 的基本绕过方法，在渗透测试过程中会举步维艰。本文列举了一些常见的 WAF 绕过方法。</p><a id="more"></a><h2 id="HTTP-参数污染"><a href="#HTTP-参数污染" class="headerlink" title="HTTP 参数污染"></a>HTTP 参数污染</h2><ul><li>由于 HTTP 协议允许同名参数存在，如果 WAF 对同名参数的处理方式不当，就会造成「参数污染」。<br>假设提交的参数为<code>id=1&amp;id=2&amp;id=3</code>，WAF 可能会解析为<code>id=1</code>，而后端的解析结果可能是<code>id=3</code>，这时候攻击者只需要把攻击内容放在第三个参数即可绕过 WAF 的检测。<br>这个方法非常古老了，现在已经基本行不通了，列出来只是为了提供一种思路。</li></ul><h2 id="HTTP-Header头欺骗"><a href="#HTTP-Header头欺骗" class="headerlink" title="HTTP Header头欺骗"></a>HTTP Header头欺骗</h2><ul><li><p>有时候 WAF 会放行特定来源（比如本地 IP 地址）的请求包，这时候就可以通过伪造请求包的来源地址来绕过 WAF。相关 HTTP 报文字段：</p><table><thead><tr><th align="center">字段</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">X-Origination-IP</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Forwarded-For</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Remote-IP</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Remote-Addr</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Client-IP</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Real-IP</td><td align="center">127.0.0.1</td></tr></tbody></table></li></ul><h2 id="HTTP-参数溢出"><a href="#HTTP-参数溢出" class="headerlink" title="HTTP 参数溢出"></a>HTTP 参数溢出</h2><p>这个方法和「参数污染」有点相似。</p><ul><li><p>一些 WAF 出于对性能的考虑，对一些参数非常多的请求只会检测其中一部分（比如前100个）参数，攻击者可以制造大量的无关参数用来「占位」，把真正的恶意参数放在后面。WAF 检测完前面一部分参数后没有发现问题，就放行了这个请求，这时候攻击者就成功绕过了 WAF 的检测，把恶意参数带入了后端。</p></li><li><p>同样是出于对性能的考虑，一些 WAF 对于超长（超大）的数据包也会跳过（不检测）。</p></li></ul><h2 id="HTTP-分块传输（Chunked）"><a href="#HTTP-分块传输（Chunked）" class="headerlink" title="HTTP 分块传输（Chunked）"></a>HTTP 分块传输（Chunked）</h2><p>「分块传输」（Chunked Transfer Coding）是一种传输编码，把报文分割成若干个大小已知的「块」进行传输。</p><ul><li>在请求报文的<code>Transfer-Encoding</code>字段中指定为<code>chunked</code>值来声明采用「分块传输」，把数据分割成若干份来绕过 WAF 的检测。</li></ul><h2 id="HTTP-数据编码（Charset）"><a href="#HTTP-数据编码（Charset）" class="headerlink" title="HTTP 数据编码（Charset）"></a>HTTP 数据编码（Charset）</h2><p>利用报文头<code>Content-Type</code>指定一个特殊编码，使服务器可以正常解析但 WAF 无法解析请求包内容，从而绕过 WAF。</p><h2 id="HTTP-Pipline（Kepp-Alive）"><a href="#HTTP-Pipline（Kepp-Alive）" class="headerlink" title="HTTP Pipline（Kepp-Alive）"></a>HTTP Pipline（Kepp-Alive）</h2><p>HTTP 管道化允许多个 HTTP 请求通过一个套接字同时被输出，而不用等待相应的响应。然后请求者会等待各自的响应，这些响应是按照之前的请求顺序依次到达。因为多个请求可被同时传送，如果 WAF 只检测第一个请求而忽略了后面的请求，就可以被绕过。</p><h2 id="HTTP-协议未覆盖"><a href="#HTTP-协议未覆盖" class="headerlink" title="HTTP 协议未覆盖"></a>HTTP 协议未覆盖</h2><p>通过修改参数提交方式导致 WAF 使用错误的方式检测请求内容，从而绕过 WAF。</p><h2 id="HTTP-畸形包"><a href="#HTTP-畸形包" class="headerlink" title="HTTP 畸形包"></a>HTTP 畸形包</h2><p>当前的 HTTP 服务依据的是 RFC2616 标准（通常有以下八种方法：OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT）的 HTTP 请求，但是当向 Web 服务器发送畸形请求（非标准的 HTTP 数据包）时，由于 Web 服务器的一些兼容性的特性，会尽力解析这些畸形的数据包，而 WAF 处理这种畸形包时就可能不拦截。</p><h2 id="HTTP-组合绕过"><a href="#HTTP-组合绕过" class="headerlink" title="HTTP 组合绕过"></a>HTTP 组合绕过</h2><p>以上列举的方法并不是一定要独立使用，可以灵活地根据情况组合使用，成功绕过的机率也会提高。</p><p>更多关于绕过 WAF 的方法，推荐阅读<a href="https://xz.aliyun.com/t/15" target="_blank" rel="noopener">这篇文章</a>。</p>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2020/04/02/WAF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>靶机-DevRandom CTF:1.1</title>
      <link>https://hack1ng4fun.github.io/2020/03/31/%E9%9D%B6%E6%9C%BA-DevRandom-CTF-1-1/</link>
      <guid>https://hack1ng4fun.github.io/2020/03/31/%E9%9D%B6%E6%9C%BA-DevRandom-CTF-1-1/</guid>
      <pubDate>Tue, 31 Mar 2020 15:55:13 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;靶机-DevRandom-CTF-1-1&quot;&gt;&lt;a href=&quot;#靶机-DevRandom-CTF-1-1&quot; class=&quot;headerlink&quot; title=&quot;靶机-DevRandom CTF:1.1&quot;&gt;&lt;/a&gt;靶机-DevRandom CTF:1.1&lt;/h1&gt;&lt;p&gt;靶机地址：&lt;a href=&quot;https://www.vulnhub.com/entry/devrandom-ctf-11,450/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DevRandom CTF:1.1&lt;/a&gt;&lt;br&gt;本机 IP：10.0.2.7，靶机 IP：10.0.2.9。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="靶机-DevRandom-CTF-1-1"><a href="#靶机-DevRandom-CTF-1-1" class="headerlink" title="靶机-DevRandom CTF:1.1"></a>靶机-DevRandom CTF:1.1</h1><p>靶机地址：<a href="https://www.vulnhub.com/entry/devrandom-ctf-11,450/" target="_blank" rel="noopener">DevRandom CTF:1.1</a><br>本机 IP：10.0.2.7，靶机 IP：10.0.2.9。</p><a id="more"></a><p>查看开放端口：</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033106.png" alt="目标主机开放端口"></p><p>嗯……很干净，只开放了 22、80 端口，22 端口简单尝试了几个弱口令，无果。去看看网页：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033142.png" alt="80 端口"><br>这个主页有点东西……扫描一下网站目录：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033134.png" alt="网站目录"><br>很明显是一个 WordPress 站点，但是访问其他页面都是同样的响应：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033124.png" alt="响应页面"></p><p>从网站扫描结果中找到了一个可以正常访问的页面：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033155.png" alt="10.0.2.9/secret/wrap"></p><p>用的还不是英语……去翻译了一下，内容是一堆不明所以的话（我是看不懂他在说什么，希望这里面没有线索-_-），页面底部有一个看起来像是<code>帐号:密码</code>的东西：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033156-1.png" alt="john:Password123"></p><p>拿去试着登录 SSH 发现登录不上，暂时不知道这是什么东西的帐号密码，先记着。</p><p>发现网站根目录下存在<code>robots.txt</code>文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033137.png" alt="robots.txt"><br><code>/wp-admin/</code>和<code>/wp-login.php</code>都是无法访问的，响应都是上面那张图片。<br>发现<code>/?include=info</code>可以正常访问：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033105.png" alt="10.0.2.9/?include=info"></p><p>看了下 HTML 源码，没发现什么东西，不过<code>?include=info</code>这个参数引起了我的注意，看起来像是可以包含文件？ 经过测试发现，这里存在 本地文件包含 或 任意文件读取 漏洞，为什么没确定漏洞类型？因为读取不到任何本地的 PHP 文件……网站的物理路径是从下面这个页面获得的（也可以通过读取 Apache 的配置文件来获得网站的物理路径）：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033141.png" alt="网站物理路径"></p><p>根据物理路径读取网站本身的 PHP 文件没有任何结果，可能是权限问题，本来想通过包含访问日志来尝试执行 PHP 代码（尝试读取了 Apache 的日志文件，也没有结果），现在是无法实现了。能正常访问的页面都没几个，别说上传点了……</p><p>好在可以读取<code>/etc/passwd</code>文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033129.png" alt="/etc/passwd"></p><p>把可以登录的用户写到一个文件，用 Hydra 爆破 SSH：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033125.png" alt="SSH 爆破"></p><p>得到一个帐号：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033132.png" alt="trevor:qwertyuiop[]"></p><p>登录上去以后，看看有没有 sudo 权限：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033158.png" alt="SSH 登录"><br>只能执行 dpkg，可以制作一个 deb 包然后使用 dpkg 安装来获取 root 权限。</p><p>在本地安装用来制作 deb 包的 FPM 工具：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033129-1.png" alt="安装 FPM"></p><p>准备一个用来提权的 Shell 脚本（它会以 root 权限执行）：<code>echo &#39;exec /bin/sh&#39; &gt; x.sh</code></p><p>使用 FPM 制作 deb 包：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033125-1.png" alt="制作 deb 包"></p><p>把生成好的 deb 包上传到目标主机，这里我是通过一个 HTTP 服务传输文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033117-1.png" alt="上传 deb 包"></p><p>使用 dpkg 安装 deb 包：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20033125-2.png" alt="安装 deb 包"><br>成功获取 root 权限！</p>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2020/03/31/%E9%9D%B6%E6%9C%BA-DevRandom-CTF-1-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>靶机-Metasploitable:1（五种方法拿到最高权限）</title>
      <link>https://hack1ng4fun.github.io/2020/03/26/%E9%9D%B6%E6%9C%BA-Metasploitable-1/</link>
      <guid>https://hack1ng4fun.github.io/2020/03/26/%E9%9D%B6%E6%9C%BA-Metasploitable-1/</guid>
      <pubDate>Thu, 26 Mar 2020 05:03:16 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;靶机-Metasploitable-1（五种方法拿到最高权限）&quot;&gt;&lt;a href=&quot;#靶机-Metasploitable-1（五种方法拿到最高权限）&quot; class=&quot;headerlink&quot; title=&quot;靶机-Metasploitable:1（五种方法拿到最高权限）&quot;&gt;&lt;/a&gt;靶机-Metasploitable:1（五种方法拿到最高权限）&lt;/h1&gt;&lt;p&gt;靶机地址：&lt;a href=&quot;https://www.vulnhub.com/entry/metasploitable-1,28/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VulnHub-Metasploitable1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;据官方描述，这个靶机有多个入口，本文将尝试以多种不同的方法进行入侵。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="靶机-Metasploitable-1（五种方法拿到最高权限）"><a href="#靶机-Metasploitable-1（五种方法拿到最高权限）" class="headerlink" title="靶机-Metasploitable:1（五种方法拿到最高权限）"></a>靶机-Metasploitable:1（五种方法拿到最高权限）</h1><p>靶机地址：<a href="https://www.vulnhub.com/entry/metasploitable-1,28/" target="_blank" rel="noopener">VulnHub-Metasploitable1</a></p><p>据官方描述，这个靶机有多个入口，本文将尝试以多种不同的方法进行入侵。</p><a id="more"></a><h2 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h2><p>先用 Nmap 找到目标 IP：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/s9dfm22.png" alt="主机发现"><br>10.0.2.7 这是我们的本机IP，目标IP应该就是 10.0.2.6 了。</p><p>对目标主机进行端口扫描和操作系统探测：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/s9dfk2ls0.png" alt="信息搜集"><br>可以看到对方 Linux 内核为：<code>Linux 2.6.x</code>，并且运行了非常多的服务，445 端口也是开放的，说明对方运行了 SMB 服务，探测一下版本：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/9sd2kva3jw.png" alt="samba版本探测"><br>没有显示确切的版本号，使用 SMBMap 再查一下：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/xcj9vmn3.png" alt="SMBMap"><br>现在得到了确切的版本号。</p><p>通过搜索发现 samba3.0.x 版本对应的一个远程命令注入漏洞：<code>CVE-2007-2447</code>，使用MSF的<code>exploit/multi/samba/usermap_script</code>模块利用此漏洞：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/v9skl2a0.png" alt="CVE-2007-2447 漏洞利用"><br>Bingo！成功返回Shell，还是root权限，至此我们已经找到了第一种入侵的办法。</p><hr><p>使用 Nmap 进行漏洞扫描：<code>nmap --script vuln 10.0.2.6 -p- --open</code>，扫描需要几分钟，先晾在那，等会再看。</p><p>通过 SMB 枚举目标系统用户：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd9f9sdk2f.png" alt="枚举系统用户"></p><p>把用户整理到一个文件中，用来爆破：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/bl23ksx9.png" alt="用户列表"></p><p>根据整理出来的用户列表逐一爆破FTP、SSH、Telnet、SMB、MySQL、PostgreSQL 服务：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/x9m2dx9.png" alt="爆破 FTP"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/x92s00z.png" alt="爆破 SSH"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/1j0xm3.png" alt="爆破 Telnet"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/x927g0as.png" alt="爆破 SMB"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/8x9c2z0.png" alt="MySQL"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/x89a3h4.png" alt="爆破 PostgreSQL"><br>通过弱口令得到了大量的帐号，看起来<code>msfadmin</code>这个用户权限会高点，通过SSH登录，查看是否有 sudo 权限：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/1jsj3lx08.png" alt="查看权限"><br>这个用户有完整的 root 权限，可通过<code>sudo -i</code>直接切换到 root 用户。<br>我们找到了第二种入侵的方式。</p><hr><p>MySQL服务也是开启的，手工测试一下弱口令看看：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/vdb230x.png" alt="尝试 MySQL 弱口令"><br>用<code>root:root</code>直接进去了……想尝试 UDF 提权，发现没有 plugin 目录，也没法创建目录，作罢。<br>随后找到一个适用于目标主机上的 MySQL 的缓冲区溢出漏洞：<code>CVE-2009-4484</code>，但是没利用成功，这个漏洞应该是存在的，可能是数据库配置问题。不在这里耗时间了，至少我们拿到了目标主机的数据库权限。</p><p>回到 Nmap 查看漏洞扫描的结果：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/df9jgbnby2.png" alt="Nmap 漏洞扫描"></p><p>很多是关于 TLS协议 的漏洞，这对我们获取权限没什么用处，不过我发现了一个可利用的漏洞：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/df32g8xerk.png" alt="CVE-2004-2687"><br>使用 MSF 的<code>exploit/unix/misc/distcc_exec</code>模块进行利用：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/hufu9d2b7.png" alt="CVE-2004-2687 漏洞利用"><br>成功返回Shell，不是root用户，还需要提权。</p><p>发现目标系统上有crontab，看下配置文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/g9tu3k46kf.png" alt="crontab 配置文件"><br>是以 root 权限运行的，看了下这些目录中的脚本，都没有写的权限，作罢。</p><p>使用 <a href="https://github.com/jondonas/linux-exploit-suggester-2" target="_blank" rel="noopener">Linux Exploit Suggester 2</a> 查看目标主机系统对应的内核版本可用的提权漏洞：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032641.png" alt="Linux Exploit Suggester 2"></p><p>为了方便操作，先把 Shell 转换为 Meterpreter Shell：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sdfkl29n.png" alt="转换 Shell 类型"></p><p>这里我用大名鼎鼎的 DirtyCOW（CVE-2016-5195）进行提权，把 <a href="https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c" target="_blank" rel="noopener">Exploit</a> 上传到目标系统（注意要上传到有写权限的目录）：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/ds9fjklb84.png" alt="上传 Exploit"><br>在目标系统上编译&amp;运行 Exploit：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/f7je23cvbzn.png" alt="编译&amp;运行 Exploit"><br>成功提权，现在<code>firefart:fly</code>帐号拥有 root 权限：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd9f2lcbh45.png" alt="/etc/passwd"></p><p>P.S：这个 Exploit 是直接把<code>/etc/passwd</code>中的用户 uid 改为0（root），它把原来的 passwd 文件备份到了<code>/tmp/passwd.bak</code>，在真实环境中使用了这个 Exploit 要记得把原先的<code>passwd</code>文件给恢复回去。</p><p>现在我们找到了第三种入侵的方式。</p><hr><p>前面一直是围绕服务端的服务漏洞进行入侵，现在来Web层看看，访问80端口：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd901lx.png" alt="访问80端口"></p><p>检查了HTML源码，确认首页什么都没有，通过扫描之后发现有个<code>/tikiwiki</code>目录：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/jsdf93lkzv.png" alt="tikiwiki 首页"><br>Tiki 是一个用 PHP+MySQL 开发的开源 CMS。<br>尝试<code>admin:admin</code>弱口令，直接进入：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/s92vz9fg.png" alt="弱口令登录"><br>简单浏览了一下，发现什么功能都没有，版本太古老了……<br>随后根据 CMS 版本找到一个远程代码执行漏洞：<code>CVE-2007-5682</code>，使用 MSF 的<code>exploit/unix/webapp/tikiwiki_graph_formula_exec</code>模块进行利用：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/231453.png" alt="CVE-2007-5682 漏洞利用"><br>成功拿到 Shell，用户是<code>www-data</code>，还需要提权。</p><p>前面我们已经知道可以用 DirtyCOW 来进行提权，但我不想让入侵的方法有任何重复，所以我找到了一个新的提权漏洞：<code>CVE-2009-1185</code>。</p><p>MSF有对应的利用模块：<code>exploit/linux/local/udev_netlink</code>，搞起来：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd9flkv248cv.png" alt="CVE-2009-1185 漏洞利用"></p><p>利用成功，返回了一个 root 权限的新 session：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/dfjp24v3by.png" alt="Meterpreter session"><br>现在已经找到了第四种入侵的方法！</p><hr><p>在一开始的扫描中就发现目标主机运行了 AJP 服务，目标主机很可能运行了 Tomcat 服务，但是 Nmap 扫描中没有直接显示，通过手动验证后确定 8180 端口是 Tomcat 服务：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sdf934klbzp.png" alt="Tomcat"><br>手工测试了几个弱口令，<code>tomcat:tomcat</code>直接命中：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/ds9f0q3vn6.png" alt="Tomcat 手工测试弱口令"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/66sdf45b.png" alt="Tomcat 弱口令命中"><br>可以直接部署 war 包来 GetShell，这里使用 MSF 模块来简化操作：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/v8s2lv9a.png" alt="Tomcat 部署 war包"><br>成功 GetShell，又是一个非 root 权限，又又又要提权了……我依然想保持入侵的方法不重复，所以前面用到的那些提权漏洞我都不会在这里重复使用，尝试了其他几个适用于目标主机的内核漏洞，都不好用，决定在服务器上看看有没有可利用的地方。</p><p>发现<code>/root/.ssh/authorized_keys</code>文件可读：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd9f2sv83.png" alt="authorized_keys 文件"><br>拿到了目标主机的 SSH 公钥，这时候想到了 Debian OpenSSL 弱随机数漏洞（CVE 2008 0166），查看后发现目标主机上的 OpenSSL 版本在漏洞范围内，这个漏洞会导致密钥生成过程中的随机值很小，所以可以利用这个漏洞来枚举密钥对，通过比对公钥来找到对应的私钥，我们就可以直接通过私钥登录目标主机的 root 用户。</p><p>网上已经有打包好的枚举出来的<a href="https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/5622.tar.bz2" target="_blank" rel="noopener">密钥对</a>，直接用就行。<br>下载 RSA 2048位加密算法的密钥对压缩包并解压：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032637.png" alt="密钥对压缩包"><br>进入<code>rsa/2048/</code>目录下，使用<code>grep</code>命令找到匹配的公钥文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032611.png" alt="匹配公钥文件"><br>把公钥文件的后缀名去掉，就是对应的私钥文件：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032629.png" alt="私钥文件"></p><p>使用这个私钥文件去登录目标主机的 root 用户：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032648.png" alt="登录系统"><br>登录成功！我们再次拿到了目标主机的最高权限。</p><hr><p>就到此为止吧，我们最终通过五种截然不同的方式拿到了目标主机的最高权限，这个靶机非常简单，适合初学者用来熟悉渗透测试中常用的工具以及渗透测试的基本步骤。实际上还有其他方式可以拿到目标主机权限，留给大家探索喽。</p><h2 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h2><p>在一开始的漏洞扫描结果中我就发现 Nmap 报告了目标主机的 Apache 存在拒绝服务漏洞（CVE-2007-6750），不过这对我们获取权限没有帮助，所以略过了，我打算在结尾简单利用一下。</p><p>HTTP 慢速攻击（SlowLoris）是通过将 HTTP 报文的长度设置为一个很大的值，然后每隔一段时间发送一点点（很少）的数据让服务器一直等待数据，导致服务器资源被持续占用，再利用多线程等方式创建大量此类连接，让服务器无法响应正常请求，最终导致拒绝服务。</p><p>使用 MSF 的<code>dos/http/slowloris</code>模块进行 HTTP 慢速攻击：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/20032634.png" alt="HTTP 慢速攻击"><br>开始攻击几秒后，网页就已经无法正常响应。</p>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2020/03/26/%E9%9D%B6%E6%9C%BA-Metasploitable-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用「经济学思维」做理性决策</title>
      <link>https://hack1ng4fun.github.io/2020/02/10/%E7%94%A8%E3%80%8C%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%80%9D%E7%BB%B4%E3%80%8D%E5%81%9A%E7%90%86%E6%80%A7%E5%86%B3%E7%AD%96/</link>
      <guid>https://hack1ng4fun.github.io/2020/02/10/%E7%94%A8%E3%80%8C%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%80%9D%E7%BB%B4%E3%80%8D%E5%81%9A%E7%90%86%E6%80%A7%E5%86%B3%E7%AD%96/</guid>
      <pubDate>Mon, 10 Feb 2020 05:26:12 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;用「经济学思维」做理性决策&quot;&gt;&lt;a href=&quot;#用「经济学思维」做理性决策&quot; class=&quot;headerlink&quot; title=&quot;用「经济学思维」做理性决策&quot;&gt;&lt;/a&gt;用「经济学思维」做理性决策&lt;/h1&gt;&lt;p&gt;人们在做各种各样的决策的时候，总是会被各种各样的商业营销、自身情绪和身处的环境所影响，导致做出非理性的选择。「经济学思维」就是把经济学的原理应用到现实生活中，帮助我们成为一个理性的人，在不同情况下能够理性地做出对自己最有益的选择。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="用「经济学思维」做理性决策"><a href="#用「经济学思维」做理性决策" class="headerlink" title="用「经济学思维」做理性决策"></a>用「经济学思维」做理性决策</h1><p>人们在做各种各样的决策的时候，总是会被各种各样的商业营销、自身情绪和身处的环境所影响，导致做出非理性的选择。「经济学思维」就是把经济学的原理应用到现实生活中，帮助我们成为一个理性的人，在不同情况下能够理性地做出对自己最有益的选择。</p><a id="more"></a><h2 id="沉没成本"><a href="#沉没成本" class="headerlink" title="沉没成本"></a>沉没成本</h2><p>「沉没成本」是指<strong>无法收回的支出</strong>，时间、金钱、精力等都是沉没成本。从决策的角度看，以往发生的费用只是造成当前状态的某个因素，当前决策所要考虑的是未来可能发生的费用及所带来的收益，而不考虑以往发生的费用。换句话说，就是沉没成本既然是无法收回的，那就不应该在决策时把它划入考虑范围，然而我们在生活中经常会过于眷恋沉没成本，导致做出不理性的行为。<br>比如说，去吃东西，吃饱之后你发现食物点多了，食物比较贵而且也没法退了，这时候你是选择强忍着把它吃完，还是不要了直接走人？在这种情况下，很多人会坚持选择把食物吃完，尽管他们知道吃完后胃会很胀，非常不舒服还有害身体健康。他们之所以会做出这样的选择就是因为他们觉得“花钱买的，不吃完岂不浪费了”，坚持吃完的结果是：钱依然花出去了，肚子却胀得难受。实际上不管有没有吃完，钱都已经花出去了（已经沉没了），这个钱就是沉没成本，在选择是不是要强撑着把食物吃完时，不应该把先前已经花出去的钱纳入考虑范围，这个时候只需要把剩下的食物当作是免费的，在吃饱后还要不要强撑着吃完呢？我相信在这样的情景下有些人的选择可能就会不一样了。<br>沉没成本导致的非理性行为在股市中也非常常见，很多人因为先前已经投入了一定的资金，尽管形势越来越糟，他们依然不肯及时抛售自己手中的股票止损，想着就算不赚钱也要等回本了再说，以至于最后血本无归。这就是因为在决策时考虑了沉没成本而导致的非理性行为，如果股民在亏损早期及时止损，也不会造成后续更大的损失，在该收手时他们不肯放弃自己已经投入的资金，进而造成了更大的损失。<br>再说一个例子：电信诈骗，电信诈骗常用的套路就是在受害者第一次上当打款后，通过一个接一个的理由哄骗受害者继续打款，以拿回先前已经支付的款项，受害者因为迫切地想要拿回自己的钱，继续给骗子汇款，想着骗子能够把所有款项都退还回来，没有及时报警，反而损失了更多的钱财。如果受害者能在第一次上当后就明白打过去的钱已经是沉没成本了，不幻想着骗子能够把钱退回来，并及时报警，也就不会发生后面追加的数次打款。</p><p>所有的投入和损失都属于过去，应该关注的是当下，依据事物的未来价值而做出理性的选择。</p><h2 id="机会成本"><a href="#机会成本" class="headerlink" title="机会成本"></a>机会成本</h2><p>在成长过程中，每个人都需要做出各种各样的选择：选择家人希望的专业还是选择自己喜欢的专业、要不要继续考研、未来从事什么方向的工作、选择自己爱的人还是爱自己的人、选择工资高但不喜欢的职业还是选择工资低但自己喜欢的职业、……，把这些选择连接起来串成线，贯穿的就是我们的整个人生。<br>在经济学中，人们要进行生产经营活动或达到一定的目的，就必须耗费一定的资源，其所费资源的货币表现称之为成本。「机会成本」指为了得到某种东西而所要放弃另一些东西中的最大价值，即采取一个<strong>A方案</strong>而放弃<strong>B方案</strong>时，<strong>B方案</strong>可能取得的收益，就是<strong>A方案</strong>的机会成本。</p><p>例子：</p><ol><li><p>比如你去找工作拿到3个Offer，一个月薪5000，一个月薪4800，一个月薪4500，你选择了月薪5000的，那么次优选择月薪4800的就是机会成本。</p></li><li><p>一个妹子同时被甲、乙、丙、丁追求，妹子最终选择了甲，后来甲月薪2万、乙月薪3万、丙月薪5万、丁月薪10万，这个妹子选择甲的机会成本就是月薪10万。</p></li></ol><p>面临选择时，想想如果选择了A会损失什么？如果选择了B又会损失什么？想清楚各个选择的机会成本，通常应该选择机会成本最低的选项，重要的是<strong>一定不要被沉没成本所影响</strong>。选择在很大程度上决定了我们的命运。</p><p>决定在一棵树上吊死，意味着你得放弃整个森林。选公司、选朋友、选恋人，不要有执念，理性选择；糟糕的公司，坑人的朋友，三观不同的恋人，该做抉择就做抉择。很多人缺少的不是成功的资本，而是选择的勇气。</p><h2 id="边际效用递减"><a href="#边际效用递减" class="headerlink" title="边际效用递减"></a>边际效用递减</h2><p>「边际效用」指的是消费者从一单位新增商品或服务中得到的效用（满意度或收益）。在一定时间内，每增加一单位的消费量所能增加的效用单位，亦即多消费商品一单位所增加的满足感幅度。</p><p>当喝第一杯奶茶的时候满足感是最高的，喝第二杯的时候感觉不错，喝第三杯、第四杯的时候就开始想吐了，奶茶所能带来的满足感随着喝的数量的增加越来越少。长期做重复的事，说同样的话，会让人产生乏味感，或新鲜感减少，经济学上叫做「边际效用递减」。</p><p>去尝试做一些没做过的事，去一些没去过的地方，永远保持对世界的好奇，快乐有时很简单。</p><h2 id="理性忽略"><a href="#理性忽略" class="headerlink" title="理性忽略"></a>理性忽略</h2><p>「理性忽略」可以看成是个体的一种有限理性。我们经常会面临众多的选择，容易在过多的选项中犹豫不决，导致错过行动的最佳时机。我们总是会“想太多”，希望掌握所有选项的所有信息后再做选择。事实上，人类的认知系统是存在各种限制的，如记忆速度、记忆容量、记忆保持的时间等，我们不可能穷尽所有信息——我们应该以一种标准去过滤掉大部分的选项，避免花费更多时间、精力去搜寻每个选项的更多信息（因为这么做的成本可能大于收益）。</p><p>当选择过多时，我们容易陷入焦虑和恐慌，生怕自己的选择不是最好的。这时候可以树立一种标准，这个标准是对于自己而言最重要的，选项必须要符合这个标准，不符合的直接忽略掉。如果最后留下来的选项依然有点多，那就继续树立一个次重要的标准，直到最后剩下了少数选择，可以开始逐个分析这些选项。</p><p>拥有选择，固然是好事，但选择过多时，也可能也会带来不好的影响，这时候就可以理性地忽略一些选择。过度追求更多的信息以供参考，这样做的结果最后可能是成本大于收益。</p><h2 id="时间成本"><a href="#时间成本" class="headerlink" title="时间成本"></a>时间成本</h2><p>「时间成本」是说，把某个时间用来做其他事情能够产生的收益。对于一个月薪 5000 的上班族来说，假设他每天工作 8 小时，每月工作 30 天，那么他的时薪就是 20 块钱，如果要他牺牲自己一个小时的上班时间去干别的事，那他干这件事的时间成本就是 20 块钱，如果说这件事本身不值这个价钱，那他就不该把上班时间花在这件事上。<br>年轻人的时间成本都是很高的，因为年轻人做的事情会对未来发展有深远的影响，学生花在学习上的时间所能带来的收益是无法估量的，付出这样的时间成本如果只是用来刷剧，显然是不理智的。我想他们之中大部分人都知道学习的重要性，但依然有很多人每天花费大量时间在刷剧等一些娱乐活动上，只是因为刷剧、打游戏这类活动的反馈周期相对于学习来说更短得多，他们能够从这类行为中快速地获得满足感。学习这种事所带来的好处只有在未来才会显现出来。人天生就是短视的，只注重当下的利益而不考虑长远的未来，这种思维模式是生活在远古时期的祖先们遗传下来的，他们那时候最大的问题就是生存，如果连活下去都是问题的话，那还考虑什么长远的打算呢，现在我们虽然已经没有老祖先们的生存问题了，但他们那时候的思维模式还遗留在我们的基因里。<br>相较于年轻人，老年人的时间成本会低得多，他们一般在家本来就没什么事干，所以经常会在大街上看到有很多老年人排着长长的队，花了半小时、一个小时的时间排队，只是为了领几个鸡蛋。他们如果没去领鸡蛋，也只是坐在一起闲聊，没有收益，他们的时间成本趋近于零，所以花这个时间去领几个鸡蛋对于他们来说是值得的。</p><p>在不同的时间段，时间成本也会不同。对于一个时薪 20 块钱的人来说，你给他每小时 30 块钱让他留下来加班，他也未必愿意，因为下班后的时间成本不一样了。本来上了一天的班就很累了，下班回家和女朋友亲热、玩玩游戏什么的娱乐一下多舒服，就为了这多 10 块钱的时薪放弃自己的下班娱乐时间，至于么？要是他正准备晚上去约会，那你给他时薪 60 他也应该不愿意。</p><p>时间是最公平的，每个人从出生就拥有，每个人的时间都一样，人与人之间的差距的产生是从把时间都花在哪了开始。时间即生命，要浪费，也是浪费在美好的事物上。</p><h2 id="番外篇：经济学思维在两性关系中的应用"><a href="#番外篇：经济学思维在两性关系中的应用" class="headerlink" title="番外篇：经济学思维在两性关系中的应用"></a>番外篇：经济学思维在两性关系中的应用</h2><p>浅谈如何把经济学的原理、方法应用在两性关系中，促进关系的进一步发展以及保持现有关系的和谐稳定。</p><h3 id="自我定价"><a href="#自我定价" class="headerlink" title="自我定价"></a>自我定价</h3><p>每个人对自己的价值都会有自己的判断：我喜欢什么样的人、我值得什么样的人喜欢我、我和什么样的人般配……一部分的判断可能是自己亲自尝试得到的，更多的可能是来自周围人对自己的评价、条件相似的人的遭遇、异性对自己的态度……最后形成了对自己的价值的一个判断，这个价值就是自己的「市场价格」。不管自认为自己的价格是多少，最终这个价格是要由“买方”决定的。就像有时候会看到一些“不搭配”的情侣，可能在你看来，这个男生明显“配不上”这个女生（女生比男生好看多了），这也只是你的评价（社会的评价），只是一个「外部定价」，这个男生真正的价格是要由这个女生（买方）决定的，她觉得男生的价格很高，那这个男生的价格就是很高，外界的评价都不重要，并不能决定男生的真正价格。</p><h4 id="提高自己的「市场价格」"><a href="#提高自己的「市场价格」" class="headerlink" title="提高自己的「市场价格」"></a>提高自己的「市场价格」</h4><p>由于你的真实价格实际上是由“买方”决定的，并且ta是主观的，那么可以通过一些小手段来提高自己的市场价格——即提高ta对你的价格评估。这里说两点——「稀缺性」和「陌生感」。</p><ul><li><p>提高稀缺性</p><p>一个物品除了它的制造成本以外，还会有一些因素导致它的价格提升，比如物品对于物主有某种纪念意义，还有一个重要的因素会影响它的价格，那就是「稀缺性」。稀缺意味着只能被少数人所拥有，人们会以拥有高稀缺性的物品作为彰显自己身份地位的手段，拥有稀缺的物品也能够给人带来幸福感。</p><p>提高自己的稀缺性可以让“买方”愿意花更高的“价钱”来拥有你，在平时的相处中对方也会对你更加宽容——对你的缺点、错误更包容。<br>说白了，提高自己稀缺性的本质就是<strong>不要让别人那么容易就得到你</strong>。具体怎么做，你自己应该可以通过这个理论自己衍生出无数小方法，什么微信不要秒回、不要那么容易被约出来、体现你的独特性、……</p></li><li><p>营造陌生感<br>行为经济学有一个被广泛应用的研究成果——陌生感带来高级感，「不明觉厉」就是这个意思。</p><p>可以有意地引导对方进入自己熟悉的领域，人家看你侃侃而谈的样子，对你的好感会增加。但是不要经常用这个方法，不然人家会觉得和你没有共同语言，适得其反。另外，在陌生的场景做陌生的事情时，我们的大脑对时间的感知会变慢，这有利于迅速拉近两个人的距离。</p></li></ul><h3 id="感情终究要回归平淡"><a href="#感情终究要回归平淡" class="headerlink" title="感情终究要回归平淡"></a>感情终究要回归平淡</h3><p>在热恋期的时候就要接受一个事实——感情最终是会回归平淡的。不管在热恋期的时候多么甜蜜、形影不离，随着在一起的时间越来越长，双方的热情也会逐渐消退，这种消退不一定代表不爱对方了，只是不像刚开始时那么腻歪了，谁都没法一直保持激情不减。随着彼此之间的了解越来越深，自己对于对方的吸引力也会随着时间被冲淡，这就是「边际效用递减」。</p><p>虽然感情终究会回归平淡，但还是可以通过一些方法，给对方带来新鲜感，让感情保持一定的温度：</p><ul><li>保持一定的神秘感</li><li>不断充实自己</li><li>增加独处的时间</li><li>……</li></ul><h3 id="帕累托优化"><a href="#帕累托优化" class="headerlink" title="帕累托优化"></a>帕累托优化</h3><p>双方至少有一方变得更好，同时没有任何一方受损。两个人恋爱后，有人因为恋爱而生活更差、心情更糟，这是一种比较差的恋爱模式。好的恋爱模式应该是两情相悦，两个人都感到比单身的时候更好了。<br>应该找相互喜欢的、都愿意为对方付出的，因为对方的出现而感到幸福。</p><h3 id="放弃「沉没成本」"><a href="#放弃「沉没成本」" class="headerlink" title="放弃「沉没成本」"></a>放弃「沉没成本」</h3><p>有些人在恋爱后，因为太爱对方而一昧地迁就、忍让对方，为对方付出的越来越多，但是最后换来的却是变本加厉，对方反而越来越不在乎自己了。恋爱关系中两个人应该是平等的，不要把自己的地位放得太低，不要牺牲自己去委曲求全，这样只会让你在对方眼里越来越廉价——不管多爱一个人，也别忘了爱自己。<br>爱情中双方当然都应该尽量包容对方，但这是两个人相互的，只靠一个人的持续付出而维持的关系，注定没结果。</p><p>如果恋情已经进行不下去了，也没有好转的趋势，就应该理性放弃，不要因为自己曾经为ta付出了那么多而不肯放手，那些都只是「沉没成本」。“没有自我”的爱换不来真正的幸福，最后只会被越伤越深。</p><p><strong>该放手时就放手，自信的你真的很美。</strong></p><h3 id="信号理论"><a href="#信号理论" class="headerlink" title="信号理论"></a>信号理论</h3><p>一般是指对于信息不对等的双方，一方通过发信号的方式使得另外一方获得己方信息，而另外一方则使用一些方式来进行筛查，过滤掉不符合预期或者目标的对象。</p><p>让对方通过实际行动（发信号）证明自己对于他的重要性和价值——如果对方是个上班族，可以适当地让他让为你付出一些金钱；如果对方是一个老板，可以让他为你花些时间……<br>看对方愿意为你付出什么，再决定是不是应该尝试进一步发展。如果自己是追求的一方，那就应该主动发出一些信号来向对方表明自己的心意。</p><h3 id="行为经济学"><a href="#行为经济学" class="headerlink" title="行为经济学"></a>行为经济学</h3><p>通过一些行为经济学的知识，帮助在约会中获得更多好感。</p><ul><li>最容易让异性产生好感的颜色是「红色」</li><li>温暖的环境/饮料会增加对方的好感；一起进行一些刺激的活动也有类似的效果</li><li>制造「小惊喜」让对方印象深刻</li><li>不要在无聊的时候结束约会，应该以甜蜜、美好的情绪结尾</li></ul>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2020/02/10/%E7%94%A8%E3%80%8C%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%80%9D%E7%BB%B4%E3%80%8D%E5%81%9A%E7%90%86%E6%80%A7%E5%86%B3%E7%AD%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux「磁盘加密」完全指南</title>
      <link>https://hack1ng4fun.github.io/2019/11/18/Linux%E3%80%8C%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E3%80%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</link>
      <guid>https://hack1ng4fun.github.io/2019/11/18/Linux%E3%80%8C%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E3%80%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sun, 17 Nov 2019 16:34:51 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Linux「磁盘加密」完全指南&quot;&gt;&lt;a href=&quot;#Linux「磁盘加密」完全指南&quot; class=&quot;headerlink&quot; title=&quot;Linux「磁盘加密」完全指南&quot;&gt;&lt;/a&gt;Linux「磁盘加密」完全指南&lt;/h1&gt;&lt;p&gt;本文只涉及 Linux 下的加密操作，如果你是在 Windows 平台下的话，直接用系统自带的「BitLocker」就可以了，图形界面操作也相对简单。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Linux「磁盘加密」完全指南"><a href="#Linux「磁盘加密」完全指南" class="headerlink" title="Linux「磁盘加密」完全指南"></a>Linux「磁盘加密」完全指南</h1><p>本文只涉及 Linux 下的加密操作，如果你是在 Windows 平台下的话，直接用系统自带的「BitLocker」就可以了，图形界面操作也相对简单。</p><a id="more"></a><p>本文中使用的 Linux 发行版是 Arch Linux，在不同发行版下的相关操作可能有所不同，以你使用的发行版官方Wiki为准。</p><h2 id="磁盘加密的意义"><a href="#磁盘加密的意义" class="headerlink" title="磁盘加密的意义"></a>磁盘加密的意义</h2><p>磁盘加密是为了保护计算机系统的物理安全（当我们不在家时如何保证电脑内数据的安全、防止系统被偷偷植入木马后门、……）。如果磁盘上存储了重要的商业机密或者是像我们这种重视隐私的人，为了防止信息泄漏以及来自线下的降维攻击），除了需要做好计算机网络、系统的安全以外，还需要考虑到物理环境下的主机安全。「安全」本身是符合「水桶理论」的，任何一个安全缺陷都会对整体的安全性造成威胁。</p><h2 id="dm-crypt"><a href="#dm-crypt" class="headerlink" title="dm_crypt"></a>dm_crypt</h2><blockquote><p>dm-crypt 是使用内核加密API框架和设备映射器（device mapper）子系统的磁盘加密系统。使用 dm-crypt，管理员可以加密整个磁盘，逻辑卷以及分区等。</p></blockquote><p>在 Linux 下通过 cryptsetup 工具来操作 dm-crypt，dm-crypt 已经被整合到 Linux Kernel 中，大部分的主流发行版都已经内置了 cryptsetup 工具，如果你使用的系统没有自带，请参考发行版的官方Wiki或网上教程进行安装。</p><h2 id="虚拟分区"><a href="#虚拟分区" class="headerlink" title="虚拟分区"></a>虚拟分区</h2><p>通过创建一个大文件来作为加密容器使用，它的好处是灵活（它本质上就是一个文件），可以很容易地复制到其他计算机上继续使用（当然需要密码）。</p><p>首先使用 fallocate 命令生成一个名为 enc 的 10GB 大小的文件容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -l 10G enc<br></code></pre></td></tr></table></figure><p>使用 cryptsetup 对文件容器进行加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup -c aes-xts-plain64 -s 512 -h sha512 -i 5000 luksFormat enc<br></code></pre></td></tr></table></figure><p>它首先会提示设备内的数据将被覆盖，是否确定，确认无误后输入 YES（大写），然后输入两次密码。<br>注：enc 是前面创建的那个文件路径，这里因为 enc 就在当前目录，所以没有写路径。</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">-c –cipher</td><td align="center">加密算法</td></tr><tr><td align="center">-s –key-size</td><td align="center">密钥大小</td></tr><tr><td align="center">-h –hash</td><td align="center">哈希算法</td></tr><tr><td align="center">-i –iter-time</td><td align="center">用来对抗暴力破解，值越大暴力破解越困难（在解密时也越耗时）</td></tr></tbody></table><p>完成后使用以下命令解密容器，并指定映射名为 myenc（这个参数不可省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup open enc myenc<br></code></pre></td></tr></table></figure><p>密码正确的话，你将在 /dev/mapper/ 目录下看到映射设备（myenc）。</p><p>解密后就可以把容器当作普通分区来操作了，先创建文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 enc<br></code></pre></td></tr></table></figure><p>挂载文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/mapper/myenc /mnt<br></code></pre></td></tr></table></figure><p>使用完后记得及时关闭，密钥将会马上从内存中被清除：</p><p>先卸载文件系统：<code>umount /mnt</code>，然后关闭加密盘<code>cryptsetup close myenc</code></p><h2 id="物理分区"><a href="#物理分区" class="headerlink" title="物理分区"></a>物理分区</h2><p>加密分区的基本操作和使用，在上面的「虚拟分区」 步骤中应该已经有所了解了，对物理分区的加密也是一样的（示例：<code>cryptsetup [参数1 参数2 ……] luksFormat /dev/sda1</code>），这里不再重复讲解。</p><h2 id="加密现有的未加密的分区"><a href="#加密现有的未加密的分区" class="headerlink" title="加密现有的未加密的分区"></a>加密现有的未加密的分区</h2><p><strong>如果你要加密根分区或 /boot 分区，还需要额外的配置工作，请参考「全盘加密」章节</strong><br><strong>如果设备中有重要数据，务必先做好备份再进行下列操作。</strong></p><p>如果要对现有的未加密分区进行加密的话，就要使用到 cryptsetup-reencrypt 命令。</p><p>假设要加密的设备是 /dev/sdx1。</p><p>首先卸载分区：<code>umount /dev/sdx1</code></p><p>因为 LUKS（Linux 硬盘加密标准）的加密头需要在分区的头部位置有 512 字节的大小，我们需要收缩文件系统的大小来给它腾出空间。（你分区的剩余空间应该够吧？……）<br>先检查文件系统：<code>e2fsck -f /dev/sdx1</code><br>收缩文件系统：<code>resize2fs -M /dev/sdx1</code>（可能需要几分钟，取决于分区大小。）</p><p>加密分区：<code>cryptsetup-reencrypt [参数1 参数2 ……] luksFormat --new --reduce-device-size 4096S /dev/sdx1</code>（因为要重新加密整个设备，如果你的分区比较大的话，我建议你在睡前进行加密操作，起床时应该就好了……）</p><p>加密完成后，解密分区：<code>cryptsetup open /dev/sdx1 www</code></p><p>再次检查文件系统（加密以后就不要操作原来的分区了，要操作解密后映射出来的设备，这里是 /dev/mapper/www）：<code>e2fsck -f /dev/mapper/www</code><br>恢复文件系统大小：<code>resize2fs /dev/mapper/www</code></p><p>完成~</p><h2 id="修改加密容器的加密参数"><a href="#修改加密容器的加密参数" class="headerlink" title="修改加密容器的加密参数"></a>修改加密容器的加密参数</h2><p><strong>如果设备中有重要数据，务必先做好备份再进行下列操作。</strong></p><p>如果在加密后想要修改加密容器的某些加密参数但不想对整个设备进行重新加密时，就会需要对现有的加密容器重新进行加密，同样是使用 cryptsetup-reencrypt 命令。</p><p>假设要重新加密的加密容器为 /dev/sdc3（这里要操作的是真实的分区，而不是映射的设备）。</p><p>首先确保加密容器已关闭，然后使用新参数对加密容器进行重新加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup-reencrypt [参数1 参数2 ……] /dev/sdc3<br></code></pre></td></tr></table></figure><p>输入密码，等待完成即可。</p><h2 id="cryptsetup-常用操作"><a href="#cryptsetup-常用操作" class="headerlink" title="cryptsetup 常用操作"></a>cryptsetup 常用操作</h2><p>到这里，你应该已经能够理解基本的加/解密操作了，在后面的操作中，一些基本的操作不会做很详细的解释。在这里我把 cryptsetup 的常用操作统一做个讲解，在后面更复杂的操作中，可以专注于主要的部分，而不是在加密命令上纠缠。</p><h3 id="密钥槽"><a href="#密钥槽" class="headerlink" title="密钥槽"></a>密钥槽</h3><p>密钥槽（Key slot）是用来表示解密密钥的“孔位”，LUKS 默认有 8 个密钥槽，也就是可以同时设置 8 个用来解密的密钥，在加密时我们已经用掉了第一个，使用 <code>cryptsetup luksDump /dev/sdx?</code>命令可以看到第一个（从 0 开始）密钥孔位已经被使用。</p><h3 id="添加新密钥"><a href="#添加新密钥" class="headerlink" title="添加新密钥"></a>添加新密钥</h3><p>新的解密密钥默认会使用下一个未使用的密钥孔位，也可以 通过 <code>-S (--key-slot)</code> 来指定要使用哪一个密钥孔位（0-7）。<br>使用 cryptsetup 的<code>luksAddKey</code> 选项添加一个新的密码或密钥文件（key-file），这里添加一个新的密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup luksAddKey /dev/sdx1<br></code></pre></td></tr></table></figure><p>提示说输入任何一个已存在的密钥槽的密码，输入密码，然后输入两次新密码即可。完成后使用 <code>cryptsetup luksDump /dev/sdx1</code> 命令可以看到现在已经有两个密钥槽被使用了，这两个密钥槽的密码都能用来解密加密容器。</p><h3 id="删除一个密钥槽"><a href="#删除一个密钥槽" class="headerlink" title="删除一个密钥槽"></a>删除一个密钥槽</h3><p>使用 cryptsetup 命令的 luksKillSlot 选项来删除孔位为 1 的密钥槽：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup luksKillSlot /dev/sdx1 1<br></code></pre></td></tr></table></figure><p>输入其他剩下的任意一个密钥槽的密码即可。</p><h3 id="key-file"><a href="#key-file" class="headerlink" title="key-file"></a>key-file</h3><p>除了密码，还可以使用 key-file 作为密钥来解密加密容器，它通常是一个随机数二进制文件。密码通常只有 10-20 位，因为有记忆成本，但是 key-file 没有这个限制。只使用 key-file 作为解密密钥，可以完全杜绝暴力破解，只要你的密钥文件不被窃取，那么它就是相对安全的。</p><p>通过 dd 命令生成一个 32KB 大小的名字为 key 的随机数文件作为 key-file：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dd <span class="hljs-keyword">if</span>=/dev/urandom of=key bs=1k count=32<br></code></pre></td></tr></table></figure><p>命令完成后，在当前目录下可以看到一个名为 key 的文件，把它加入到密钥槽：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cryptsetup luksAddKey /dev/sdx? key(密钥文件路径)<br></code></pre></td></tr></table></figure><p>输入其他任意一个已有的密钥槽的密码。<br>如果你只想使用 key-file 来解密容器，添加成功后删除原来的密钥槽即可。</p><p>如果在加密时想使用 key-file 作为密钥，方法也是一样的：<code>cryptsetup luksFormat /dev/sdd? key(密钥文件)</code></p><p>在解密时使用<code>-d (--key-file)</code>参数指定密钥文件：<code>cryptsetup open /dev/sdx? myenc -d key(密钥文件)</code></p><h3 id="在启动时解密设备"><a href="#在启动时解密设备" class="headerlink" title="在启动时解密设备"></a>在启动时解密设备</h3><p>/etc/crypttab 文件类似于 fstab 文件，用来在启动时解密被加密的设备。<br>crypttab 文件于 fstab 文件之前被加载，这样可以在设备被解密后通过 fstab 文件正常挂载设备。</p><p>示例文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf">#&lt;name&gt;       &lt;device&gt;                                      &lt;password&gt;              &lt;options&gt;<br><br> home         UUID&#x3D;b8ad5c18-f445-495d-9095-c9ec4f9d2f37    &#x2F;etc&#x2F;mypassword1<br> data1        &#x2F;dev&#x2F;sda3                                    &#x2F;etc&#x2F;mypassword2<br> data2        &#x2F;dev&#x2F;sda5                                    &#x2F;etc&#x2F;cryptfs.key<br> swap         &#x2F;dev&#x2F;sdx4                                    &#x2F;dev&#x2F;urandom            swap,cipher&#x3D;aes-c<br></code></pre></td></tr></table></figure><p>配置文件总共有四个字段，分别是映射设备名、加密设备、用来解密的密钥文件（key-file）、选项，第一和第二个字段是必需的。</p><p>省略第三个字段或把第三个字段设置为<code>none</code>、<code>-</code>则表示在解密时手动输入密码。</p><p>如果要在系统启动时通过手动输入密码来解密 /dev/sdx1，配置文件可以写为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">myenc &#x2F;dev&#x2F;sdx1 none<br></code></pre></td></tr></table></figure><p>系统在启动过程中会要求输入密码来解密设备。</p><p>如果要在解密后自动挂载设备，只需要像正常设备一样配置 fstab 文件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">&#x2F;dev&#x2F;mapper&#x2F;myenc(映射设备名) &#x2F;home ext4 rw,relatime 0 2<br></code></pre></td></tr></table></figure><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul><li>关于 crypttab 文件的详细信息可以看<a href="http://www.jinbuguo.com/systemd/crypttab.html" target="_blank" rel="noopener">这里</a></li><li>关于 cryptsetup 命令的详细信息可以看<a href="https://linux.die.net/man/8/cryptsetup" target="_blank" rel="noopener">这里</a></li><li>关于 cryptsetup-reencrypt 命令的详细信息可以看<a href="http://man7.org/linux/man-pages/man8/cryptsetup-reencrypt.8.html" target="_blank" rel="noopener">这里</a></li></ul><h2 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h2><p>这部分主要讲解如何在 Linux 下实现<strong>包含 /boot 分区的全盘加密</strong>。</p><h3 id="加密-boot-的必要性"><a href="#加密-boot-的必要性" class="headerlink" title="加密 /boot 的必要性"></a>加密 /boot 的必要性</h3><p>/boot 分区中包含第二阶段引导所需要的内核文件，加密 /boot 分区可以缓解大部分在启动过程中发生的攻击。（但仍然可能受到 BIOS/UEFI 固件篡改、冷启动攻击、硬件键盘记录器等攻击手段的威胁，这超出了本文范围，在此不作解释。）</p><p>Grub 是支持 /boot 分区加密的，我们会使用它来作为我们的引导加载程序。（不过 Grub 有一个小限制，下面会谈到。）</p><h3 id="加密方案"><a href="#加密方案" class="headerlink" title="加密方案"></a>加密方案</h3><p>要对系统进行「全盘的」加密，首先需要选择一种加密方案，以下有几种常见的加密方案，后续会针对这几种加密方案进行加密操作：<br><strong>如果你使用 UEFI 引导：不管在什么情况下，EFI 分区都是不能被加密的。</strong></p><ol><li>LVM 物理卷在加密容器下（先加密了整个分区，然后在加密分区中创建了 LVM物理卷。）</li><li>加密容器在 LVM 下（对 LVM 划分出来的逻辑卷进行加密。PS:逻辑卷可能有多个，如果想加密所有逻辑卷，那么需要分别对各个逻辑卷进行加密。）</li><li>没有使用 LVM 的普通分区</li><li>额外需要注意的问题：/boot 是否要进行单独分区？</li></ol><p>来说说以上这几种分区布局应该如何进行加密，以及它们之间的一些区别：</p><p>第一种和第二种方案是使用 LVM 的情况，区别在于 LVM 和 加密容器的层级关系不同，如果 LVM 物理卷是创建在加密容器之下的，那么 LVM 的分区布局对外是不可见的，因为它被外层的加密容器所保护；如果加密容器是在 LVM 之下的话，实际上就是加密了 LVM 下的逻辑卷，这种情况下，LVM的分区布局对外是透明的，它本身（LVM）并没有被加密，被加密的是它底下的那些逻辑卷，第二种方案可以支持加密与非加密分区的混合使用，只加密需要加密的分区，具体操作和普通的分区加密没区别，这个章节说的是全盘加密，会假设所有逻辑卷都需要加密。<br>除了布局的可见性以外，第一和第二种方案还有一个区别，就是内核钩子的加载顺序，第一种情况需要先加载 dm-crypt 模块解密容器，然后 LVM 逻辑卷才会被映射出来，后续才能被正常挂载、使用；第二种情况则是需要 LVM 模块先加载，然后加载 dm-crypt 来解密逻辑卷。</p><p>第三种情况是没有使用 LVM，这是最普通的情况，这种情况和第二种情况基本相同，只是它不再需要加载 LVM 模块。</p><p>还有一个需要注意的点，就是 /boot 目录是否要进行单独分区？ /boot 目录包含了系统引导时所需要的内核文件，如果要加密 /boot 分区，需要「引导加载程序」支持，Grub 就支持加密的 /boot 分区，我们使用它作为引导加载程序，但是 Grub 只支持 LUKS1 加密（cryptsetup 默认会使用 LUKS2，LUKS1 和 LUKS2 的主要区别在于 LUKS2 拥有更多功能，别担心，LUKS1 也是一样安全的），所以会有两种情况：/boot 进行了单独分区，在加密 /boot 分区时要指定<code>-M luks1</code>参数；/boot 没有进行单独分区，它和根分区在同一分区，那么就要在加密根分区的时侯指定<code>-M luks1</code>参数。</p><h3 id="全盘加密-操作"><a href="#全盘加密-操作" class="headerlink" title="全盘加密-操作"></a>全盘加密-操作</h3><p>已经详细讲过的操作在接下来不会讲得很细，需要的时候我依然会进行一些说明。</p><ul><li><p>LVM 在加密容器中<br>这里通过一个稍微复杂点的布局来说明各种操作。<br>假设总共创建了三个分区，分别是<code>/dev/sdx1</code>、<code>/dev/sdx2</code>和<code>/dev/sdx3</code>， <code>/dev/sdx1</code>作为 EFI 分区（如果你是BIOS引导则不需要此分区），<code>/dev/sdx2</code> 作为 /boot 分区，<code>/dev/sdx3</code>中打算用来创建 LVM 物理卷。<br>这里的 /boot 目录进行了单独分区，对它进行单独加密并指定使用 LUKS1：<code>cryptsetup luksFormat  -M luks1 /dev/sdx2</code><br>打开加密容器：<code>cryptsetup open /dev/sdx2 boot</code><br>为 /boot 分区创建文件系统：<code>mkfs.ext4 /dev/mapper/boot</code><br>加密 <code>dev/sdx3</code>：<code>cryptsetup luksFormat /dev/sdx3</code><br>打开加密容器：<code>cryptsetup open /dev/sdx3 root</code><br>创建文件系统用来存储物理卷：<code>mkfs.ext4 /dev/mapper/root</code><br>创建物理卷：<code>pvcreate /dev/mapper/root</code><br>创建名为 main 的卷组：<code>vgcreate main /dev/mapper/root</code><br>创建用来挂载在 /home 目录的逻辑卷：<code>lvcreate -L 500G(大小) -n home(名字) main</code><br>创建用来作根分区的逻辑卷：<code>lvcreate -L 500G -n root main</code><br>为逻辑卷分别创建文件系统（命令省略）。<br>把逻辑卷分别挂载好，就可以正常安装系统了，安装好系统再进行下一步。<br>前面说了，LVM 和 dm-crypt 的加载是有顺序的，这里需要先加载 dm-crypt 来解密容器，然后再加载 LVM。为了能够输入密码，还需要在 dm-crypt 之前先加载 keyboard 模块，LVM 和 dm-crypt 对应的模块名分别是<code>lvm2</code>和<code>encrypt</code>。 内核钩子的配置文件在 Arch Linux 的位置是 /etc/mkinitcpio.conf，<code>HOOKS</code>这一行就是内核钩子了，把<code>keyboard</code>、<code>encrypt</code>和<code>lvm2</code> 插入到合适的位置，正确的顺序大概是这样的（keyboard 模块只要在 dm-crypt 模块之前加载就没问题）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">HOOKS&#x3D;(base udev autodetect keyboard modconf block encrypt lvm2 filesystems fsck)<br></code></pre></td></tr></table></figure><p>修改了内核钩子后，要重新生成 initramfs：<code>mkinitcpio -p linux</code><br>安装引导（如果没安装 Grub，请先安装）：<code>grub-install --target=x86_64-efi --efi-directory=/efi</code><br>这里我以 UEFI 引导为例并假设 EFI 分区挂载在 /efi 目录，如果你使用 BIOS 引导的话参考这条命令：<code>grub-install --target=i386-pc /dev/sdx(根分区)</code><br>修改 Grub 内核启动参数（/dev/default/grub），修改<code>GRUB_CMDLINE_LINUX=</code>这一行配置，用来在引导时解密根分区，格式为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">GRUB_CMDLINE_LINUX&#x3D;&quot;cryptdevice&#x3D;UUID&#x3D;加密容器的UUID，可以通过 blkid 命令查看:映射设备名 root&#x3D;根分区&quot;<br></code></pre></td></tr></table></figure><p>我的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">GRUB_CMDLINE_LINUX&#x3D;&quot;cryptdevice&#x3D;UUID&#x3D;42ad71f4-d8a3-4ce5-8c38-7eb608008e35:root root&#x3D;&#x2F;dev&#x2F;mapper&#x2F;main-root&quot;<br></code></pre></td></tr></table></figure><p>开启 Grub 的加密选项，用来在引导时解密 /boot 分区，将<code>GRUB_ENABLE_CRYPTODISK=</code>选项设置为<code>GRUB_ENABLE_CRYPTODISK=y</code><br>生成 Grub 配置文件：<code>grub-mkconfig -o /boot/grub/grub.cfg</code></p><p>现在已经完成了全盘加密，在引导过程中会要求你输入密码解密 /boot 分区，随后在启动系统时会再次要求你输入密码以解密根分区。如果你觉得麻烦，只想在开机时输入一个密码，可以通过把密钥嵌入到 initramfs 中实现，这里不作演示。</p><p>知识补充：<br>在解密根分区的时候，实际上就是在解锁加密容器，因为根分区包含在加密容器中，加密容器解锁之后，在它下面的那些逻辑卷也就自然解锁了，除了 /boot 和 根分区的解密需要在引导过程中完成，其他像 /home /var 之类的普通分区可以通过设置 /etc/crypttab 文件和 /etc/fstab 文件来在系统启动后自动解密并挂载，把密钥文件放在加密的根分区中（一定不要放在未加密的分区中，那等于白送……），在解密容器的过程中系统会自动读取密钥文件，而不用手动输入密码，同时因为密钥文件本身是存放在加密的根分区中，在根分区解密之前，它会得到保护。</p></li><li><p>加密容器在 LVM 中<br>这个方案的操作和上面的大同小异，只是加密容器和 LVM 的层级不同，内核钩子的顺序和上面的不一样（LVM 先加载，然后加载 encrypt）；这种情况下逻辑卷都是单独加密的，要给除了根分区和 /boot 分区以外的逻辑卷都添加一个密钥文件用来启动时自动解密（如果要手动输入的话，逻辑卷比较多时岂不是要输到怀疑人生？），这样在启动时就只需要手动输入根分区和 /boot 分区的密码，系统成功启动后就会自动解密、挂载其他剩下的逻辑卷。</p></li><li><p>没有使用 LVM</p><p>这种情况和「加密容器在 LVM 中」的操作是基本相同的，只是不需要加载 lvm2 的内核钩子了（<del>因为没有用到嘛</del>），其他的配置和「加密容器在 LVM 中」没有区别。</p></li><li><p>/boot 和根分区在同一分区</p><p>这种情况下，在加密根分区时一定要记得使用 LUKS1 加密，如果因为某些原因根分区一定要用 LUKS2，那就把 /boot 目录拉出来单独分区，单独使用 LUKS1 加密。<br>在这种情况下你会发现一个问题：为什么 /boot 目录和根分区在同一分区，但是在启动时却需要输入两次密码？这是因为 Grub 在解锁分区后不会传递给 initramfs，第一次是为 Grub 输入密码，第二次是为 initramfs。解决办法是把密钥文件嵌入到initramfs 中。</p></li></ul>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2019/11/18/Linux%E3%80%8C%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E3%80%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>「云安全」篇</title>
      <link>https://hack1ng4fun.github.io/2019/10/16/%E3%80%8C%E4%BA%91%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/</link>
      <guid>https://hack1ng4fun.github.io/2019/10/16/%E3%80%8C%E4%BA%91%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/</guid>
      <pubDate>Tue, 15 Oct 2019 16:43:41 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;「云安全」篇&quot;&gt;&lt;a href=&quot;#「云安全」篇&quot; class=&quot;headerlink&quot; title=&quot;「云安全」篇&quot;&gt;&lt;/a&gt;「云安全」篇&lt;/h1&gt;&lt;p&gt;企业上云，特别是一些初创企业，「上云」已经是一种趋势，包括一些大型企业一般也会选择「混合云」，所以作为安全人员，掌握和了解「云安全」相关知识可以帮助你在原本的基础上加大优势和筹码。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="「云安全」篇"><a href="#「云安全」篇" class="headerlink" title="「云安全」篇"></a>「云安全」篇</h1><p>企业上云，特别是一些初创企业，「上云」已经是一种趋势，包括一些大型企业一般也会选择「混合云」，所以作为安全人员，掌握和了解「云安全」相关知识可以帮助你在原本的基础上加大优势和筹码。</p><a id="more"></a><h2 id="云计算（cloud-computing）"><a href="#云计算（cloud-computing）" class="headerlink" title="云计算（cloud computing）"></a>云计算（cloud computing）</h2><h3 id="什么是「云计算」"><a href="#什么是「云计算」" class="headerlink" title="什么是「云计算」"></a>什么是「云计算」</h3><p>「云计算」是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。云是网络、互联网的一种比喻说法。过去在图中往往用云来表示电信网，后来也用来表示互联网和底层基础设施的抽象。因此，云计算甚至可以让你体验每秒10万亿次的运算能力，拥有这么强大的计算能力可以模拟核爆炸、预测气候变化和市场发展趋势。用户通过电脑、笔记本、手机等方式接入数据中心，按自己的需求进行运算。</p><p>云计算（Cloud Computing）是分布式计算（Distributed Computing）、并行计算（Parallel Computing）、效用计算（Utility Computing）、 网络存储（Network Storage Technologies）、虚拟化（Virtualization）、负载均衡（LoadBalance）、热备份冗余（High Available）等传统计算机和网络技术发展融合的产物。</p><h3 id="「云计算」的定义"><a href="#「云计算」的定义" class="headerlink" title="「云计算」的定义"></a>「云计算」的定义</h3><p>对云计算的定义有多种说法。对于到底什么是云计算，至少可以找到100种解释。 现阶段广为接受的是美国国家标准与技术研究院（NIST）定义：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p><h3 id="公有云-私有云-混合云"><a href="#公有云-私有云-混合云" class="headerlink" title="公有云/私有云/混合云"></a>公有云/私有云/混合云</h3><p>「公有云」可以理解为类似腾讯云、阿里云这种，其实就是公有云平台，那么他们提供的云服务，其实就是一种公有云服务，因为使用者是各种企业和个人；而与之相对的「私有云」就是指企业自建的云服务，企业自己使用而不像腾讯云、阿里云等对外提供服务；而「混合云」就是混合两者的情况了，有些企业会选择多个公有云平台然后加上自己搭建私有云的形式来给公司业务提供计算服务，这种架构和设计就是混合云。</p><h2 id="云安全"><a href="#云安全" class="headerlink" title="云安全"></a>云安全</h2><p>随着「云计算」这个概念的出现，自然在安全领域就产生了「云安全」这个概念。那么什么又是云安全？通俗的理解，在传统反病毒领域，云安全其实就是一种基于「云」技术的安全应用，比如云查杀；而其实就基于云计算而言，可能不限于是安全应用，还有就是就是围绕着云计算的安全对抗，是传统网络安全在「云」这一领域的延伸，包括安全产品，所以有的时候大家会发现，云安全做的事情或者产品其实跟传统网络安全似乎差别不大，可能只是将对抗的战场从传统服务器变成了云环境，又或者是产品架构上更适应公有云、混合云等情况；再者就是云是基于虚拟化技术，所以自然而然也包括虚拟化安全，但是你又会发现这其实也是传统网络安全的一部分。</p><p>云安全从本质上与传统的网络安全区别并不大，云服务的提供包含有云计算服务(也就是云主机)、存储、网络、数据库服务、大数据服务、在线计算服务、短信服务、人工智能服务等等，那么这里面就有一大堆的安全风险，自然衍生安全保障、对抗、检测、防护等需求，比如说主机安全，也就是传统服务器安全，传统的解决方案是 IDS（入侵检测系统）；还有 DDoS（分布式拒绝服务攻击），解决方案是抗D产品，包含流量清洗、高防等；再者，比如云主机在漏洞的方面其实跟传统服务器上的漏洞也一样，包含操作系统漏洞、服务漏洞、部署业务漏洞等，这些点其实都是一致的。</p><h3 id="主机安全"><a href="#主机安全" class="headerlink" title="主机安全"></a>主机安全</h3><h4 id="「暴力破解」与「异地登录」"><a href="#「暴力破解」与「异地登录」" class="headerlink" title="「暴力破解」与「异地登录」"></a>「暴力破解」与「异地登录」</h4><h5 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h5><p><strong>「暴力破解」就是密码枚举的过程：</strong>事先生成一份可能的密码列表（通常叫作「字典」），然后遍历字典（将里面的密码逐一尝试）。<br>例如：针对云主机的「远程登录」进行暴力破解，破解成功将可以直接获取云主机的服务器权限。</p><p>可以通过「登录日志」来查看是否有相关的尝试登录的操作（暴力破解会有大量的登录尝试记录），如果其中有登录状态为成功的记录，表明主机的登录密码已经被成功破解。</p><p>防御：</p><ul><li>使用复杂的口令（Linux建议使用公/私钥登录，放弃口令登录）</li><li>修改默认登录端口</li><li>通过防火墙或者云厂商提供的安全组等方式进行白名单的登录，禁止非白名单的 IP 登录</li><li>安装一些主机安全软件进行对应的防御和检测</li></ul><h5 id="异地登录"><a href="#异地登录" class="headerlink" title="异地登录"></a>异地登录</h5><p>登录地区不是自身（或工作人员）所在的地区，来自陌生地区的登录记录。</p><p>暴力破解成功的原因在于「云主机存在系统弱口令」；<br>异地登录则可能是黑客「通过其他漏洞或其他方式获得了服务器权限」。</p><p>防御：</p><p>登录成功证明黑客已经获得了主机的帐号密码，意味着服务器存在安全问题，需要排查入侵原因，再进行对应的修复与防御（同时可以屏蔽恶意登录的IP的访问；也可以通过白名单的方式限制访问）。</p><h4 id="病毒木马与WebShell"><a href="#病毒木马与WebShell" class="headerlink" title="病毒木马与WebShell"></a>病毒木马与WebShell</h4><p>针对云主机的病毒往往功能上更趋向于如挖矿、加密勒索、对外DDoS、后门程序等利用云主机资源的行为或控制云主机，不会存在如盗号等功能性的木马。</p><h4 id="在云主机上检测-WebShell-和病毒木马"><a href="#在云主机上检测-WebShell-和病毒木马" class="headerlink" title="在云主机上检测 WebShell 和病毒木马"></a>在云主机上检测 WebShell 和病毒木马</h4><h5 id="病毒木马的检测"><a href="#病毒木马的检测" class="headerlink" title="病毒木马的检测"></a>病毒木马的检测</h5><ul><li>云查杀</li><li>通过本地引擎进行特征检测、沙箱行为检测</li><li>利用「机器学习」等方法进行样本的训练，对恶意文件进行检测</li></ul><h5 id="WebShell-的检测"><a href="#WebShell-的检测" class="headerlink" title="WebShell 的检测"></a>WebShell 的检测</h5><p>D盾、安全狗、云镜、安骑士等安全产品都具有对 WebShell 的检测能力</p><p>对于 WebShell 和病毒木马的检测，除了使用相关的安全产品，也可以利用一些在线工具进行检测或者进行人工的文件分析。</p><h5 id="病毒木马与-WebShell-的处理"><a href="#病毒木马与-WebShell-的处理" class="headerlink" title="病毒木马与 WebShell 的处理"></a>病毒木马与 WebShell 的处理</h5><p>删除恶意文件，排查云主机上是否存在其他恶意文件，检查有哪些系统配置和文件被改动过了……；</p><p>排查入侵原因：WebShell 往往是因为云主机里Web服务存在漏洞而导致将WebShell上传；病毒木马往往是通过系统漏洞或者云主机上的服务漏洞而导致病毒木马的植入。</p><h4 id="服务器安全加固"><a href="#服务器安全加固" class="headerlink" title="服务器安全加固"></a>服务器安全加固</h4><ul><li>关闭非必要服务等，减少攻击面</li><li>修复安全问题，解决已有隐患</li><li>优化策略，增加限制，提高入侵难度</li><li>优化日志存储，提供「可溯源」</li></ul><h4 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h4><h5 id="主机内可以用来判断机器是否被入侵的信息"><a href="#主机内可以用来判断机器是否被入侵的信息" class="headerlink" title="主机内可以用来判断机器是否被入侵的信息"></a>主机内可以用来判断机器是否被入侵的信息</h5><ul><li>异常的文件落地</li><li>异常的登录行为</li><li>异常的网络请求（DNS、HTTP请求、反弹Shell、……）</li><li>敏感文件变更和特殊行为（crontab 等敏感文件被更改、异常的命令执行等）</li><li>……</li></ul><h3 id="应用安全"><a href="#应用安全" class="headerlink" title="应用安全"></a>应用安全</h3><h4 id="云WAF"><a href="#云WAF" class="headerlink" title="云WAF"></a>云WAF</h4><p>WAF 全称是「Web Application Firewall（Web应用防火墙）」，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的产品。</p><h5 id="WAF的三种类型"><a href="#WAF的三种类型" class="headerlink" title="WAF的三种类型"></a>WAF的三种类型</h5><ul><li><p>硬件防火墙<br>以一个独立硬件盒子的方式串行部署在Web服务器前端，主要是通过串接到交换机上，这样经过交换机的所有HTTP流量都会经过防火墙进行识别和检测，针对恶意流量直接拦截。</p><ul><li>优点<ul><li>部署简单</li><li>由于是硬件形式的，一般可承受的吞吐量会比较大，性能比较高</li></ul></li><li>缺点<ul><li>价格昂贵</li><li>通常是离线部署，也就意味着存在规则无法实时更新的问题</li></ul></li></ul></li><li><p>软件防火墙<br>以软件的形式直接安装在服务器上。 这类防火墙的实现方式通常是通过 WAF 监听端口或以Web容器拓展的方式来进行请求的检测和阻断。</p><ul><li>优点<ul><li>安装简单——下载就可以安装使用</li><li>有些产品是免费的</li></ul></li><li>缺点<ul><li>需要消耗服务器资源</li><li>不适合大型Web应用</li></ul></li></ul></li><li><p>云WAF<br>近几年开始流行的一种 WAF，它的主要实现方式是利用 DNS 技术，通过移交域名解析权来实现安全防护：用户的请求首先发送到云端节点进行检测，如果存在异常请求则进行拦截，否则将请求转发至真实服务器。</p><ul><li>优点<ul><li>部署比 软件WAF 更简单</li><li>对网站主而言，基本没有运维成本（云WAF厂商会自己跟踪最新漏洞然后添加对应规则，并实时更新到各个节点）</li><li>规则实时更新，用户无感知</li><li>由于 云WAF 的多节点部署方式，通常还带有 CDN 的功能，自动为访问的用户分配最近的节点，于是在访问速度上就能得到提升</li></ul></li><li>缺点<br>由于是采用 DNS 的方式，假如Web应用的真实IP泄漏了，那么就可以绕过 WAF 进行Web攻击。</li></ul></li></ul><p>选用哪种类型的 WAF 主要取决于实际的业务场景，不过一般情况下，大部分的业务场景都是可以直接使用 云WAF 的。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/CloudWAF.png" alt="云WAF 工作原理示意图"></p><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h4><p>DoS 是「Denial of Service 拒绝服务」，而 DDoS 就是「Distributed Denial of Service 分布式拒绝服务」。</p><p>DoS攻击 就是「在短时间内发起大量请求，耗尽服务器的资源」，导致网站无法响应正常的访问，从而实现「拒绝服务」。</p><p>按照 TCP/IP 的层次，可将 DDoS攻击 分为：</p><ul><li>基于 ARP 的攻击</li><li>基于 ICMP 的攻击</li><li>基于 IP 的攻击</li><li>基于 UDP 的攻击</li><li>基于 TCP 的攻击</li><li>基于 应用层 的攻击</li></ul><h5 id="几种特殊的、容易混淆的DDos类型"><a href="#几种特殊的、容易混淆的DDos类型" class="headerlink" title="几种特殊的、容易混淆的DDos类型"></a>几种特殊的、容易混淆的DDos类型</h5><ul><li>CC攻击</li></ul><p>CC攻击 是一种特殊的DDoS攻击，主要针对网站页面，攻击者通过代理服务器或肉鸡向受害者主机不停地发送大量数据包，造成对方服务器资源耗尽，一直到宕机崩溃。</p><p>这种攻击见不到 源IP，也没有特别大的异常流量，但造成了服务器无法进行正常连接。这种攻击技术含量低，利用一些IP代理和更换代理IP的工具，一个初、中级电脑水平的用户就能够实施攻击。</p><p>CC攻击 的特点是，它是针对网站页面发起的，CC攻击的每个请求都是正常的访问，之所以能够达到攻击的目的是因为网站在响应每个页面请求的时候，可能会涉及到数据库查询、数据处理等操作，然后再响应页面内容；这些操作都是需要消耗服务器资源的，当访问量过大的时候，就导致页面无法正常响应正常的请求，也就实现了攻击的目的。</p><ul><li>UDP反射放大攻击</li></ul><p>「UDP反射放大攻击」是指，攻击者不是直接发起对攻击目标的攻击，而是利用互联网上开放的某些服务，通过伪造被攻击者的地址为请求源IP，向该服务器发送基于 UDP 的特殊报文，数倍于请求报文的回复的数据被发送到被攻击者IP，从而对后者间接形成 DDoS攻击。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/8s9df.png" alt="UDP反射放大攻击 示意图"></p><h5 id="DDoS-防护"><a href="#DDoS-防护" class="headerlink" title="DDoS 防护"></a>DDoS 防护</h5><ul><li>流量清洗</li></ul><p>「流量清洗」就是鉴别接收流量中哪些是属于异常的攻击流量，把这部分流量丢弃，然后其他正常流量再到达源服务器。通常实现流量清洗的做法是将流量从原始网络路径中重定向到清洗设备上。</p><p>通过流量清洗可以减缓攻击对服务器造成的损害，但对流量中正常的部分可能造成损伤。</p><ul><li><p>流量清洗的常规方法</p><ul><li><p>近源清洗</p><p>屏蔽攻击源地址的那部份地区的访问（舍弃那部份地区的所有访问（其中当然也有来自正常用户的访问），保全其他地区用户的正常访问，属于一种「弃车保帅」的做法）。</p></li><li><p>近目的清洗</p><p>在接近「攻击目的地」的地方，针对来自可能不同地方的攻击流量进行清洗。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/Flowcleaning.png" alt="流量清洗 示意图"></p><ul><li>黑洞</li></ul><p>「黑洞」是指服务器受攻击流量超过机器所在机房黑洞阀值时，云厂商会屏蔽服务器的外网访问。</p><p>传统早期的「黑洞」是位于机房入口处，现在的「黑洞」一般是由运营商提供的服务，在运营商侧丢弃流量，这样就可以大大缓解 DDoS攻击 对机房带宽的压力。</p><ul><li>高防IP</li></ul><p>「高防机房」要求有足够大的出口带宽，这样才能抗得住足够大的攻击流量，「高防IP」就是高防机房的IP段。</p><p>通过配置高防IP，比如将域名解析到高防IP，再设置源IP，这样所有公网流量都会先经过高防机房，然后再进行清洗过滤后将正常的流量返回给源站IP，从而确保源站IP的稳定访问。</p><ul><li>DDoS防护包</li></ul><p>直接把防御能力加载到云产品上，而无需配置流量转发等。这种防护只能应用在云厂商的云产品。</p><h4 id="云防火墙与安全组"><a href="#云防火墙与安全组" class="headerlink" title="云防火墙与安全组"></a>云防火墙与安全组</h4><ul><li>安全组</li></ul><p>一种有状态的包过滤功能虚拟防火墙，用于设置单台或多台云服务器的网络访问控制，是云厂商提供的重要的网络安全隔离手段。</p><ul><li>云防火墙<ul><li>流量识别与可视</li><li>入侵检测</li><li>防火墙策略管理</li></ul></li></ul><h4 id="VPC（Virtual-Private-Cloud）"><a href="#VPC（Virtual-Private-Cloud）" class="headerlink" title="VPC（Virtual Private Cloud）"></a>VPC（Virtual Private Cloud）</h4><p>公有云的网络一般分为「经典网络」（也称为基础网络）和 VPC。经典网络就是「公有云上所有用户共享公共网络资源池，用户之间未做逻辑隔离」。用户的内网IP由系统统一分配，相同的内网IP无法分配给不同用户。</p><ul><li><p>经典网络的一些风险</p><ul><li>可以确定内网中的其他机器百分百是服务器，就不用判断目标机器是否是一台服务器，提高了端口扫描的效率</li><li>经典网络的IP段都是连续的，为扫描带来了更多便利</li><li>通过<code>route</code>命令查看路由表，还可以发现很多其他的内网网段</li><li>在内网发起攻击，速度自然也快，可能还没安全监控</li><li>可能还可以对供应商的控制系统发起攻击</li></ul></li></ul><p>以上的解决方案就是 VPC——一种运行在公有云上，将一部分公有云资源为某个用户隔离出来，给这个用户私有使用的资源的集合。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/VPC.png" alt="VPC与经典网络的区别"></p><p>VPC 相对于经典网络来说，可细化配置的项更多，对应的一些安全隔离配置也允许进行更复杂的操作。</p><ul><li>网络ACL（Access Control List 访问控制列表）</li></ul><p>是一个子网级别无状态的可选安全层，用于控制进出子网的数据流，可以精确到协议和端口粒度。如下图所示，其规则与 安全组 相似，但由于网络 ACL 无状态的特性，设置入站规则允许某些访问后，如果没有设置相应的出站规则，也会导致无法响应访问。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/ACL.png" alt="网络ACL 示意图"></p><p>在使用一些云主机的时候，如果不是出于业务需要，建议都使用 VPC 网络，需要互相访问的业务可以放到同一个网络，然后再辅以安全组和ACL规则配置，就能最大限度地降低云主机或者数据服务等被入侵的风险。</p><h3 id="业务安全"><a href="#业务安全" class="headerlink" title="业务安全"></a>业务安全</h3><h4 id="风险防控"><a href="#风险防控" class="headerlink" title="风险防控"></a>风险防控</h4><p>安全是对抗风险，所以业务安全其实就是属于业务风险的范畴。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd9flsdm2pzl.png" alt="业务安全"></p><p>常见保护方案</p><ul><li>登录保护<br>识别盗号、撞库、自动机登录、……</li><li>注册保护<br>识别恶意注册、小号注册机、机器注册、……</li><li>防刷保护<br>防范「薅羊毛」的行为。相关识别功能主要是分析用户的行为和帐号的风险等级，能有效地识别「羊毛党」。</li><li>验证码</li></ul><p>识别技术的核心要点：</p><ul><li>数据采集、上报</li><li>行为模型</li><li>信誉库（IP库、设备库等）</li></ul><h4 id="内容安全"><a href="#内容安全" class="headerlink" title="内容安全"></a>内容安全</h4><blockquote><p>互联网信息发布单位包括网络接入单位，从事信息服务的联网单位，开办电子公告版、新闻组、提供广播式发送电子邮件功能的联网单位等，这些信息发布单位必须建立和完善自己单位的互联网信息内容安全管理制度，严格依照法律规定进行信息内容安全管理，否则要承担相应的责任。</p></blockquote><ul><li><p>主要的内容类型</p><ul><li>文字<ul><li>聊天内容</li><li>评论、留言、弹幕内容</li><li>签名、昵称、个人介绍</li><li>论坛发帖、回帖</li><li>……</li></ul></li><li>图片<ul><li>头像、背景图</li><li>评论、留言等里面的图片</li><li>聊天中的图片</li><li>文章、商品介绍中的图片</li><li>……</li></ul></li><li>视频<ul><li>直播</li><li>点播</li><li>上传视频</li><li>短视频</li><li>……</li></ul></li><li>音频<ul><li>语音通信</li><li>直播音频</li><li>点播音频</li><li>……</li></ul></li></ul></li><li><p>根据《计算机信息网络国际联网安全保护管理办法》规定，发布的信息不得含有以下内容：</p><ul><li>违反宪法所确定的基本原则</li><li>危害国家安全，泄露国家秘密，煽动颠覆国家政权，破坏国家统一</li><li>损害国家的荣誉和利益</li><li>煽动民族仇恨、民族歧视，破坏民族团结</li><li>破坏国家宗教政策，宣扬邪教，宣扬封建迷信</li><li>散布谣言，编造和传播假新闻，扰乱社会秩序，破坏社会稳定</li><li>散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪</li><li>侮辱或者诽谤他人，侵害他人合法权益</li><li>法律、法规禁止的其他内容</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2019/10/16/%E3%80%8C%E4%BA%91%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>「渗透测试」篇</title>
      <link>https://hack1ng4fun.github.io/2019/10/13/%E3%80%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8D%E7%AF%87/</link>
      <guid>https://hack1ng4fun.github.io/2019/10/13/%E3%80%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8D%E7%AF%87/</guid>
      <pubDate>Sun, 13 Oct 2019 06:02:47 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;「渗透测试」篇&quot;&gt;&lt;a href=&quot;#「渗透测试」篇&quot; class=&quot;headerlink&quot; title=&quot;「渗透测试」篇&quot;&gt;&lt;/a&gt;「渗透测试」篇&lt;/h1&gt;&lt;p&gt;渗透测试（penetration test）是通过「模拟黑客的攻击方法」来评估计算机网络安全的一种评估方法，包括对系统的任何弱点、技术缺陷或漏洞的主动分析。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="「渗透测试」篇"><a href="#「渗透测试」篇" class="headerlink" title="「渗透测试」篇"></a>「渗透测试」篇</h1><p>渗透测试（penetration test）是通过「模拟黑客的攻击方法」来评估计算机网络安全的一种评估方法，包括对系统的任何弱点、技术缺陷或漏洞的主动分析。</p><a id="more"></a><h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><ol><li><p>信息收集<br>主机、域名、系统、社会工程学、……<br>在渗透测试过程中很重要的一个环节，<strong>渗透测试的本质就是信息收集</strong>。</p></li><li><p>安全测试<br>利用第一阶段（信息收集）收集到的信息，进行安全测试。<br>安全测试的主要内容包括XSS、SQL注入、命令执行、文件上传、业务漏洞、……<br>除了针对Web系统的安全测试，还可以针对目标主机的端口开放情况进行测试。</p></li><li><p>横向渗透<br>在第二阶段找到漏洞点并成功利用漏洞进入目标系统后，通过在目标系统内进行提权、信息收集、建立代理（利用此系统作为跳板，访问内网）等方式获取更多信息。</p></li><li><p>报告输出<br>将挖掘到的漏洞、利用手法和漏洞验证，以及渗透测试的流程进行文档化输出。<br>对目标系统上的Shell、后门进行清理。</p></li></ol><h2 id="常见的信息收集方法"><a href="#常见的信息收集方法" class="headerlink" title="常见的信息收集方法"></a>常见的信息收集方法</h2><p>作为渗透测试前期最主要的步骤，需要以更加细心的态度去进行信息收集。信息收集这一步的质量好坏，直接决定了能否成功地渗透进入目标系统（或达到渗透测试目标）。</p><ul><li>域名（主域名/子域名）<ul><li>域名注册信息（Whois）</li><li>子域名爆破</li></ul></li><li>真实IP/IP段<br>通过域名解析出来的IP，来确定目标可能使用的 IP段。对于有 CDN 的域名，可以通过 SSRF、信息泄漏、发送邮件等方式获取目标真实IP。<br>对于大型公司，可能会有 AS号（自治系统号码，用来标识独立的自治系统），可以通过<code>bgp.he.net</code>来查询 AS号。</li><li>网站信息收集<ul><li>网站敏感目录</li><li>邮箱</li><li>Web服务器指纹</li><li>Web应用指纹</li><li>HTML源码<br>有些时候，开发者会在网站 HTML源码 里嵌入一些未公开的接口或者其他信息等。</li><li>Web目录爆破</li><li>Web服务器探测<ul><li>开放端口（服务）</li><li>系统版本</li><li>……</li></ul></li></ul></li><li>利用搜索引擎进行信息收集<ul><li>Google Hacking<br>子域名、敏感信息、敏感目录、……</li><li>GitHub<br>很多开发者可能会误将一些敏感配置文件、公司代码、邮箱密码等，上传到GitHub上，这就造成了安全隐患。</li><li>Shodan<br>一个「网络空间搜索引擎」</li><li>ZoomEye<br>国产的和 Shodan 类似的产品</li></ul></li><li>员工信息</li><li>邮箱信息</li><li>……</li></ul><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/collect.png" alt="信息搜集"></p><h2 id="服务漏洞"><a href="#服务漏洞" class="headerlink" title="服务漏洞"></a>服务漏洞</h2><p>「服务」就是某个主机的应用程序提供的一些服务性功能（HTTP服务、FTP服务、数据库服务、……），服务一般会对应着某个端口（HTTP服务-80端口、FTP服务-21端口、MySQL服务-3306端口、……）。</p><p>服务安全是主机安全的一个重点，服务的漏洞会导致主机沦陷。除了测试Web应用外，更要注重的是，对于服务的发现与漏洞的挖掘。</p><h3 id="「Nmap」的使用"><a href="#「Nmap」的使用" class="headerlink" title="「Nmap」的使用"></a>「Nmap」的使用</h3><p>Nmap 是一个「网络扫描工具」，可以用来检测主机是否在线、端口是否开启，还可以检测目标主机的操作系统；Nmap 也提供了 NSE（Nmap scripting Engine）功能（一个强大的脚本插件，内含多种服务漏洞的检测）。</p><p>利用 Nmap 对网段进行「主机发现」:<code>nmap 10.0.2.0/24 -sP</code></p><p>对指定 IP 进行全端口扫描：<code>nmap 10.0.2.15 -p- -n -v --open</code></p><p>检测每个（开放的）端口所运行的服务，并使用 Nmap 默认的 NSE 脚本进行安全检测：<code>nmap 10.0.2.15 -p- -n -v --open -sC -sV --version-all</code></p><h3 id="一些典型的服务安全漏洞"><a href="#一些典型的服务安全漏洞" class="headerlink" title="一些典型的服务安全漏洞"></a>一些典型的服务安全漏洞</h3><ul><li>IIS<ul><li>PUT 漏洞</li><li>短文件名猜解</li><li>远程代码执行</li><li>解析漏洞</li></ul></li><li>Apache<ul><li>解析漏洞</li><li>目录遍历</li></ul></li><li>Nginx<ul><li>文件解析</li><li>目录遍历</li><li>CRLF注入</li></ul></li><li>Tomcat<ul><li>远程代码执行</li><li>war 后门文件部署</li></ul></li></ul><h2 id="进入内网的常用方法"><a href="#进入内网的常用方法" class="headerlink" title="进入内网的常用方法"></a>进入内网的常用方法</h2><ul><li>端口转发</li><li>内网穿透</li></ul><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><p>Metasploit 是一个「渗透测试集成框架」，简称「MSF」。MSF 内含许多攻击模块，涵盖了包括从操作系统到Web应用的漏洞利用（Exploit）、后渗透模块、扫描模块等。</p><p>通常来说，MSF 是渗透测试人员的必备工具，掌握 MSF 是渗透测试人员必须的技能。</p><h2 id="常见的提权方式"><a href="#常见的提权方式" class="headerlink" title="常见的提权方式"></a>常见的提权方式</h2><p>提权的目的是「获取到更高的权限后，能收集更多的信息」。</p><ul><li><p>Windows<br>Windows 下的提权是利用系统漏洞进行提权，主要通过 MSF 来进行。</p></li><li><p>Linux</p><ul><li>内核提权</li><li>一些错误配置导致的提权</li><li>……</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2019/10/13/%E3%80%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E3%80%8D%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>「Web安全」篇</title>
      <link>https://hack1ng4fun.github.io/2019/10/12/%E3%80%8CWeb%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/</link>
      <guid>https://hack1ng4fun.github.io/2019/10/12/%E3%80%8CWeb%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/</guid>
      <pubDate>Sat, 12 Oct 2019 04:46:48 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;「Web安全」篇&quot;&gt;&lt;a href=&quot;#「Web安全」篇&quot; class=&quot;headerlink&quot; title=&quot;「Web安全」篇&quot;&gt;&lt;/a&gt;「Web安全」篇&lt;/h1&gt;&lt;p&gt;扫盲Web安全领域的主流漏洞，深入了解漏洞的产生原理以及对应的防御方法。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="「Web安全」篇"><a href="#「Web安全」篇" class="headerlink" title="「Web安全」篇"></a>「Web安全」篇</h1><p>扫盲Web安全领域的主流漏洞，深入了解漏洞的产生原理以及对应的防御方法。</p><a id="more"></a><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器机制"><a href="#浏览器机制" class="headerlink" title="浏览器机制"></a>浏览器机制</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><ul><li><p>不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。</p></li><li><p>同一个域的定义</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul></li><li><p>如果在未授权的情况下发起一个跨源请求，将会被浏览器拦截，并报错：<code>CORS头缺少&#39;Access-Control-Allow-Origin&#39;</code>，也就是缺少必要的HTTP头。浏览器实际上是拦截了跨源请求的响应。</p></li><li><p>虽然有同源策略在，但是是可以协商的。只要被请求的一方用某种方式允许了你的访问，就可以突破同源策略的限制。</p></li><li><p>业务上常见的允许跨源的例子</p><ul><li>jsonp<br>jsonp的本质是跨源的对方给你一段JavaScript脚本让你执行，而script标签的src属性是允许跨源的，所以达到了跨源的目的。</li><li>CORS<br>CORS的原理是被请求的服务端获取到发出请求方的请求后，给响应头加上<code>AccessControl-Allow-Origin</code>相关信息，浏览器就会对响应放行，让对方拿到数据。</li><li>WebSocket<br>WebSocket是一种通信协议，使用<strong>ws://</strong>(非加密) 和<strong>wss://</strong>(加密) 作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。</li></ul></li></ul><h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><ul><li>HTML、CSS、JS的解析顺序<br><strong>HTML &gt; CSS &gt; JS</strong></li><li>浏览器的解码顺序<br><strong>HTML &gt; URL &gt; JS</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/render.png" alt="浏览器渲染页面到屏幕上的主流程"></p><h3 id="浏览器安全策略"><a href="#浏览器安全策略" class="headerlink" title="浏览器安全策略"></a>浏览器安全策略</h3><h4 id="CSP内容安全策略（Content-Security-Policy）"><a href="#CSP内容安全策略（Content-Security-Policy）" class="headerlink" title="CSP内容安全策略（Content Security Policy）"></a>CSP内容安全策略（Content Security Policy）</h4><ul><li>什么是CSP？<br>为了缓解很大一部分潜在的跨站脚本问题，浏览器的拓展程序引入了CSP的概念。这将引入一些非常严格的安全策略，会使拓展程序在默认情况下更加安全。开发者可以创建并强制应用一些规则，管理网站加载的内容。简单来说，我们的网站只接受我们指定的资源。</li><li>CSP的意义<br> 等同防XSS等攻击的利器。CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</li><li>CSP的使用方法<ul><li>在HTTP Header上使用（首选）<ul><li><code>Content-Security-Policy:&quot;策略&quot;</code></li><li><code>Content-Security-Policy-Report-Only:&quot;策略&quot;</code></li></ul></li><li>在HTML上使用<ul><li><code>&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;策略&quot;&gt;</code></li><li><code>&lt;meta http-equiv=&quot;content-security-policy-report-only&quot; content=&quot;策略&quot;&gt;</code></li></ul></li></ul></li></ul><p><strong>虽然CSP可以控制的策略非常多，但在实际应用中很少有企业能把它设置正确。</strong></p><h4 id="Cookie安全"><a href="#Cookie安全" class="headerlink" title="Cookie安全"></a>Cookie安全</h4><ul><li>主要是domain、path、secure和HttpOnly的组合</li></ul><h4 id="iframe沙盒"><a href="#iframe沙盒" class="headerlink" title="iframe沙盒"></a>iframe沙盒</h4><ul><li>iframe沙盒框架是对常规&lt;iframe&gt;表现行为的拓展</li><li>它能让顶级页面对其嵌入的子页面及这些子页面的子资源设置一些额外的限制</li><li>通过设置&lt;iframe&gt;的<strong>sandbox</strong>属性实现限制</li></ul><h4 id="flash安全沙箱"><a href="#flash安全沙箱" class="headerlink" title="flash安全沙箱"></a>flash安全沙箱</h4><ul><li>Flash的安全沙箱其实和同源策略有关，主要是针对跨源请求的，需要在被请求的站点下的<strong>crossdomain.xml</strong>路径下用xml的格式输出允许跨源请求的站点。</li><li>现在flash逐渐被淘汰，对于这个策略，了解即可。</li></ul><h2 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h2><ul><li>什么是OWASP？</li></ul><p>OWASP（Open Web Application Security Project）即「开放式Web应用程序安全项目」。是一个开源的、非盈利的全球性安全组织，主要致力于应用软件的安全研究。组织使命是使应用软件更加安全，使企业和组织能够对应用安全风险作出更清晰的决策。</p><p>主要成果是共同推动了安全标准、安全测试工具、安全指导手册等应用安全技术的发展。OWASP被视为Web应用安全领域的权威。</p><h3 id="OWASP-TOP-10"><a href="#OWASP-TOP-10" class="headerlink" title="OWASP TOP 10"></a>OWASP TOP 10</h3><p><strong>OWASP TOP 10</strong>被用来分类网络安全漏洞的严重程度，目前被许多漏洞奖励平台和企业安全团队引用。</p><p>这个列表总结了Web应用程序最可能、最常见、最危险的十大漏洞，IT公司和开发团队可以利用这个列表来规范应用程序开发流程和测试流程，提高Web产品的安全性。</p><p>基本所有的Web漏洞扫描都会被要求满足<strong>OWASP TOP10</strong>的检测，同时相关企业在招聘Web安全人才的时候也要求掌握<strong>OWASP TOP 10</strong>。</p><p><strong>OWASP TOP 10</strong>是隔几年发一次，最近的两次<strong>OWASP TOP 10</strong>分别是「2017版」和「2013版」。</p><h4 id="OWASP-TOP-10-2017版"><a href="#OWASP-TOP-10-2017版" class="headerlink" title="OWASP TOP 10 2017版"></a>OWASP TOP 10 2017版</h4><ol><li><p>注入（injection）<br>将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p></li><li><p>失效的身份认证（Broken Authentication）<br>通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌， 或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。<br>主要是指比如密码破解、会话劫持等身份认证相关漏洞。</p></li><li><p>敏感数据泄露（Sensitive Data Exposure）<br>许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据 以及浏览器的交互数据。</p></li><li><p>XML外部实体（XML External Entities）<br>许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃 取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。<br>就是指<strong>XXE</strong>这种漏洞类型。</p></li><li><p>失效的访问控制（Broken Access Control）<br>未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。<br>比如说未授权访问、越权漏洞等都属于这一类型。</p></li><li><p>安全配置错误（Security Misconfiguration）<br>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云 存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p></li><li><p>跨站脚本（Cross-Site Scripting）<br>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器 中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。<br>特指XSS这个漏洞类型。</p></li><li><p>不安全的反序列化（Insecure Deserialazation）<br>不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以 利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。<br>比如JAVA反序列等。</p></li><li><p>使用含有已知漏洞的组件（ Useing Components with Known Vulnerabilities）<br>组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏 洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组 件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。<br>这类型也比较好理解，比如Linux里使用存在破壳漏洞的bash版本，就属于这个类型，通用组件漏洞。</p></li><li><p>不足的日志记录和监控（Insufficient Logging&amp;Monitoring）<br>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超 过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。<br>比如由于缺乏相关的日志记录和监控，导致相关入侵无法被及时发现，或者被发现后无法进行相关的溯源。</p></li></ol><h2 id="常见Web漏洞"><a href="#常见Web漏洞" class="headerlink" title="常见Web漏洞"></a>常见Web漏洞</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><p>攻击者往Web页面里插入恶意的Script代码，当用户访问该页面时，嵌入其中的恶意代码将会被执行，从而达到恶意攻击用户的目的。XSS还经常和CSRF漏洞结合利用，以造成更大的危害。</p><h4 id="主流XSS类型"><a href="#主流XSS类型" class="headerlink" title="主流XSS类型"></a>主流XSS类型</h4><ul><li>DOM型XSS</li><li>反射型XSS</li><li>存储型XSS</li></ul><h4 id="其他XSS类型"><a href="#其他XSS类型" class="headerlink" title="其他XSS类型"></a>其他XSS类型</h4><ul><li><p>mXSS 突变型XSS<br>由于编码等问题导致Payload变异而产生的XSS</p></li><li><p>UXSS 通用型XSS<br>利用浏览器或者浏览器拓展漏洞来制造产生XSS的条件并执行代码的一种攻击类型<br>一般导致的后果就是Bypass同源策略<br>严格来说UXSS应该算不上传统的XSS</p></li><li><p>FlashXSS<br>由Flash导致的XSS<br>问题主要出现在Flash的实现代码上</p></li><li><p>只存在于低版本IE浏览器的XSS（少见）</p><ul><li><p>UTF-7 XSS<br>特定IE版本下以UTF-7编码处理网页内容，导致XSS。<br>UTF-7编码场景下的XSS，对应攻击Payload也要转换为UTF-7编码的结果。</p></li><li><p>MHTML XSS<br>IE浏览器下的一种特殊类型的XSS，因为是源于仅限低版本IE浏览器支持的一个MHTML协议进行攻击的。</p></li><li><p>CSS XSS<br>由于CSS支持的特性导致只在低版本IE下可能导致的XSS。</p></li><li><p>VBScript XSS<br>仅在低版本IE下支持的由VBScript语句构建的XSS。</p></li></ul></li></ul><h4 id="XSS攻击和防御"><a href="#XSS攻击和防御" class="headerlink" title="XSS攻击和防御"></a>XSS攻击和防御</h4><ul><li><p>挖掘XSS漏洞步骤</p><ol><li>寻找注入点</li><li>查看提交的内容是否注入到了页面</li><li>根据注入点位置的DOM结构，构造Payload</li></ol></li><li><p>XSS利用</p><ul><li>JavaScript能做的，它都能做。<ul><li>内网端口扫描</li><li>信息收集</li><li>执行代码</li><li>通过BeEF平台丰富的XSS工具进行利用</li><li>……</li></ul></li></ul></li><li><p>XSS盲打<br>不管提交什么内容，页面都只会返回特定相同的内容，而不会因为提交的内容不同而不同。<br>这种情况下无法通过页面返回的内容来判断提交的XSS代码是否执行成功，这时候就需要用到「XSS盲打平台」。</p></li><li><p>XSS盲打平台<br>将XSS盲打平台生成的XSS代码插入到漏洞点（怀疑有漏洞的位置），如果XSS代码被成功执行了，那么在XSS盲打平台的后台就能看到相应的信息，表明此处存在XSS漏洞。<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/sd92ks9zk.png" alt="XSS盲打平台"></p></li><li><p>XSS防御</p><ul><li>针对 script 等特殊标签做HTML转义，让Payload失效。</li><li>WAF</li><li>CSP（内容安全策略）</li><li>语言开发框架</li></ul></li></ul><h3 id="跨站请求伪造-CSRF"><a href="#跨站请求伪造-CSRF" class="headerlink" title="跨站请求伪造(CSRF)"></a>跨站请求伪造(CSRF)</h3><p>可以在受害者毫不知情的情况下，以受害者的名义伪造请求，发送给受攻击的站点。从而在并未授权的情况下执行在权限保护之下的操作。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/csrf.png" alt="CSRF 攻击原理"></p><p>攻击的前提条件：必须是在用户登录了网站的基础上，用同个浏览器去访问攻击者构造的钓鱼页面。（向网站发送请求时才会携带网站的用户Cookie，才能攻击成功。）</p><h4 id="CSRF漏洞的利用"><a href="#CSRF漏洞的利用" class="headerlink" title="CSRF漏洞的利用"></a>CSRF漏洞的利用</h4><p>假设某网站，在修改用户密码的位置存在CSRF漏洞，用户在修改密码时会发送如下一个请求：<br><code>http://localhost/?passwd=1234&amp;submit=submit</code><br><code>passwd</code>字段是用户的新密码</p><p>在用户登录状态下访问这个URL，用户的密码就会被修改为<code>passwd</code>字段的值（1234）。</p><p>攻击者构造了如下一个钓鱼页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.jpg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"300px"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none;"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://localhost/?passwd=hacked&amp;submit=submit"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设用户当前是登录状态，当用户打这个钓鱼页面时，用户只会看到一个美女图片（1.jpg），实际上他的密码已经被修改为 hacked（通过一个隐藏的iframe标签向网站发送了一个修改密码的请求）。这个例子就是攻击者通过CSRF漏洞，以用户的身份修改了用户密码。<br>CSRF漏洞具体能做到什么，要看出现漏洞的具体功能点，如果银行转账功能出现CSRF漏洞，那么攻击者就能通过漏洞转走你账户的钱……</p><h4 id="CSRF的防御手段"><a href="#CSRF的防御手段" class="headerlink" title="CSRF的防御手段"></a>CSRF的防御手段</h4><ul><li><p>构造随机内容的提交参数</p><ul><li>增加随机参数（验证码、Token、……）</li></ul></li><li><p>验证HTTP请求是否正常</p><ul><li>验证HTTP请求的Referer</li></ul></li></ul><p>具体功能增加防护措施的时候，可以根据功能场景进行改进。</p><h3 id="目录穿越（目录遍历）与文件包含"><a href="#目录穿越（目录遍历）与文件包含" class="headerlink" title="目录穿越（目录遍历）与文件包含"></a>目录穿越（目录遍历）与文件包含</h3><h4 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h4><p>由于Web服务器或Web应用程序对用户输入文件名称的安全性验证不足而导致的一种安全漏洞。<br>可绕过服务器的安全限制，访问任意受限的文件（可以是Web根目录以外的文件，比如：数据库配置文件、Linux的密码文件），甚至执行系统命令。</p><p>典型的目录穿越漏洞：<br><code>http://localhost/file.php?filename=../../../../../../etc/passwd</code><br><code>..</code>代表的是上一层目录，这里的<code>../../../../../../etc/passwd</code>意思是往前跳多层目录，直到跳到根目录下，再加上要读取的文件路径：<code>/etc/passwd</code>，就实现了读取Web服务器系统的任意文件。</p><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>在开发的时候会有一些共用的代码，在多个文件中会复用，开发人员往往会把这样的代码或者方法写在一个文件里，通过文件包含的方法直接包含到代码里进行使用。</p><p>#####　本地文件包含</p><p>假设网站有如下两个PHP文件：</p><p>file.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span>($_GET[<span class="hljs-string">'filename'</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>phpinfo.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> phpinfo(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>那么当访问<code>http://localhost/file.php?filename=phpinfo.php</code>时，<code>phpinfo.php</code>文件就会被包含到<code>file.php</code>中执行，最后就会打印出phpinfo信息。<br><code>file.php</code>在包含文件的时候并没有对<code>$_GET[&#39;filename&#39;]</code>的值做相关的处理，「filename」的参数可以是任意的，这就意味着这里存在「本地文件包含漏洞」。</p><h5 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><p>既然有「本地文件包含」，那自然也有「远程文件包含」啦，如果<code>php.ini</code>的配置选项<code>allow_url_fopen</code>和<code>allow_url_include</code>都为 ON 的话，被包含的文件就可以是HTTP的URL形式或者是<code>php://</code>、<code>data://</code>等特殊协议，意味着可以包含（执行）远程的文件。<br>被包含的远程PHP文件，后缀名应该改为txt，否则读取到的会是远程PHP文件被解析后的结果。</p><p>在利用「文件包含漏洞」的时候，经常会结合「目录穿越漏洞」来读取<code>/etc/passwd</code>等敏感文件。</p><h4 id="文件包含和目录穿越的防御"><a href="#文件包含和目录穿越的防御" class="headerlink" title="文件包含和目录穿越的防御"></a>文件包含和目录穿越的防御</h4><ul><li>设置白名单<br>将要包含的文件都写入到白名单，非白名单的包含文件都直接拒绝。</li><li>设置<code>php.ini</code>相关配置选项<ul><li>关闭远程文件包含<br>关闭<code>allow_url_fopen</code>和<code>allow_url_include</code>选项</li><li>设置<code>open_basedir</code>选项<br>通过设置<code>open_basedir</code>选项的值，将允许访问（包含）的文件限定在某一特定目录内。</li></ul></li></ul><h3 id="JSONP（JSON-with-Padding）安全与防御"><a href="#JSONP（JSON-with-Padding）安全与防御" class="headerlink" title="JSONP（JSON with Padding）安全与防御"></a>JSONP（JSON with Padding）安全与防御</h3><h4 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP"></a>什么是 JSONP</h4><p>基于 JSON 格式，为解决跨域请求资源而产生的解决方案。<br>它的基本原理是利用script元素标签远程调用JSON文件来实现数据传递。</p><h4 id="JSON劫持（JSON-Hijacking）"><a href="#JSON劫持（JSON-Hijacking）" class="headerlink" title="JSON劫持（JSON Hijacking）"></a>JSON劫持（JSON Hijacking）</h4><p>典型的JSON劫持攻击是通过定义一个跟JSON接口中callback参数值相同的函数来接收JSON接口的数据，以此获取到目标用户敏感信息。</p><p>JSON劫持和CSRF非常相似，JSON劫持也可以理解为CSRF的一种应用场景，它们的攻击手法也基本相同，只不过CSRF的目的是发送请求，而JSON劫持是为了获取用户的敏感信息。攻击者首先诱导受害者进入钓鱼页面，钓鱼页面会向网站的JSON接口发送请求，用户如果当前是登录状态，发送请求时就会携带网站的用户Cookie，网站就会返回相关的用户信息，攻击者就成功获取到了用户的敏感信息。</p><h4 id="JSONP-的安全问题"><a href="#JSONP-的安全问题" class="headerlink" title="JSONP 的安全问题"></a>JSONP 的安全问题</h4><p>如果「callback参数」可以随意修改，是可控的话，还可能导致XSS漏洞。存在XSS的前提是<strong>接口返回内容的<code>Content-Type</code>设置不正确</strong>（或者没有设置），就有可能导致XSS漏洞的产生。</p><p>除了由于自定义callback函数名可以导致XSS以外，由于这个函数的自定义问题以及开发者在编码等方面的开发不严谨，也可能会导致其他一些不常见的安全问题，这里不再深入。</p><h4 id="JSON劫持的防御"><a href="#JSON劫持的防御" class="headerlink" title="JSON劫持的防御"></a>JSON劫持的防御</h4><ul><li>验证调用方（referer、……）</li><li>增加随机Token</li></ul><h4 id="XSS问题的防御"><a href="#XSS问题的防御" class="headerlink" title="XSS问题的防御"></a>XSS问题的防御</h4><ul><li>对callback函数的长度进行限制<br>XSS的Payload往往必须要有一定的长度，才能产生真实的危害。</li><li>对内容（callback参数值、返回内容）进行特殊字符的过滤</li></ul><h3 id="HTML5-安全问题与防御"><a href="#HTML5-安全问题与防御" class="headerlink" title="HTML5 安全问题与防御"></a>HTML5 安全问题与防御</h3><p>HTML5 是定义 HTML 标准的最新的版本，它是HTML的第五次重大修改，标准于14年10月29日完成。</p><p>作为 HTML 的升级版，HTML5 引入了更多的标签、属性、方法、功能、……安全问题都是伴随着功能出现的，HTML5 自然而然就产生了一些可以被利用的安全问题，或者说，扩大了原来的一些攻击方法的攻击面/攻击点。</p><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>HTML5 带来的新标签、新属性为XSS恶意代码「绕过WAF等防护设备的黑名单机制」提供了便利：可以尝试使用更多不同的标签、属性绕过防护设备的安全检测，执行恶意代码。这方面的防御主要看防护产品是否增加了对新标签、新属性的检测。</p><h4 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h4><p>CORS是一个W3C标准，全称是「跨域资源共享」（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>服务端在响应头中设置<code>Access-Control-Allow-Origin</code>字段来表明接受哪些网站的跨域请求（还有其他几个与CORS请求相关的字段，这里只讲最重要的这个），如果开发人员偷懒，为了方便，将<code>Access-Control-Allow-Origin</code>字段的值设置为「<em>」的话，这表明接受任何网站的跨域请求，如果同时使用了<code>Access-Control-Allow-Credentials:true</code>将导致CORS的安全机制几乎完全失效，这就会导致安全问题。考虑到这种权限过于宽松，CORS又规定，`Access-Control-Allow-Origin:</em><code>与</code>Access-Control-Allow-Credentials:true`不能同时使用。浏览器会对下面这种误配置报错：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span>: *  <br><span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true<br></code></pre></td></tr></table></figure><p>CORS标准规定，<code>Access-Control-Allow-Origin</code>只能配置为单个origin，null或*，<br>如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用框架来协助动态生成访问控制策略。这种动态生成的做法增加了开发者配置难度，导致实际网络中出现各种不安全的误配置。</p><p>最简单地动态生成访问控制策略的方法，就是在<code>Access-Control-Allow-Origin</code>中反射请求的Origin值。例如，下面是一个错误 Nginx 配置示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">add_header <span class="hljs-string">"Access-Control-Allow-Origin"</span> $http_origin;<br>add_header “Access-Control-Allow-Credentials” “<span class="hljs-keyword">true</span>”;<br></code></pre></td></tr></table></figure><p>这种配置相当于信任任何网站，任意攻击者都可以直接跨域读取网站资源。</p><p>「Shell of the Future」工具就是利用CORS建立HTTP通道，将页面发送给控制端（攻击者），可以绕过一些反会话劫持的方法（Http-Only限制的Cookie、绑定IP地址的会话ID、……），实现XSS会话劫持。</p><p>如果某个内部站点没有对外网开放，但CORS被设置为接受所有跨域请求，身在外部的攻击者同样可能通过构造钓鱼页面，诱导内部工作人员访问，通过内部工作人员的网络就可以成功访问到内部站点，从而获取到外网访问不到的敏感信息。</p><p>防御：对于跨域请求，验证身份、验证数据有效性、……</p><h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><p>「Web Storage」 实际上由两部分组成：</p><ul><li>sessionStorage<br>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</li><li>localStorage<br>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li></ul><p>由于是浏览器本地存储，而其API都是通过JavaScript提供的，那么意味着一旦重要、敏感的数据采用这种存储方式，攻击者就可以通过XSS攻击窃取信息。</p><p>防御：避免存储敏感信息到WebStorage</p><h4 id="WebSQL"><a href="#WebSQL" class="headerlink" title="WebSQL"></a>WebSQL</h4><p>HTML5 引入了一组使用 SQL 操作客户端数据库的 APIs。</p><p>既然是数据库操作，那么就会存在一些比如注入等问题。</p><p>防御：防护措施和SQL注入也是类似的，比如过滤关键词等。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>HTML5 引入了一些新的API，可以实现新的攻击方法。</p><p>由于 HTML5 涉及的API比较多，就不一一展开了。给一个「通过History新的API来隐藏恶意URL」的例子，可以搭配短网址来隐藏反射型XSS的攻击代码，以下为一个反射型XSS的URL：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://localhost/xss/?xsscode=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">history.pushState(&#123;&#125;,<span class="hljs-string">''</span>,location.href.split(<span class="hljs-string">'?'</span>).shift());<span class="hljs-built_in">document</span>.write(<span class="hljs-number">1</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用户访问页面后，XSS攻击代码被成功执行，但用户看到的URL却是<code>http://localhost/xss</code>，达到了隐藏恶意URL的效果。</p><h3 id="点击劫持-Click-jacking"><a href="#点击劫持-Click-jacking" class="headerlink" title="点击劫持(Click jacking)"></a>点击劫持(Click jacking)</h3><p>点击劫持又称「UI覆盖攻击」，是一种视觉上的欺骗手段，它主要有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/clickjacking.png" alt="点击劫持说明图"></p><p>点击劫持的攻击原理比较简单，如果了解HTML、CSS的话应该不难理解。</p><h4 id="点击劫持的防御"><a href="#点击劫持的防御" class="headerlink" title="点击劫持的防御"></a>点击劫持的防御</h4><ul><li>使用<code>X-Frame-Options</code>响应头</li></ul><p>如果是通过JavaScript方法来禁止iFrame嵌套，存在被绕过的风险。</p><h3 id="URL跳转（重定向）"><a href="#URL跳转（重定向）" class="headerlink" title="URL跳转（重定向）"></a>URL跳转（重定向）</h3><p>借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。</p><h4 id="URL跳转漏洞实现过程"><a href="#URL跳转漏洞实现过程" class="headerlink" title="URL跳转漏洞实现过程"></a>URL跳转漏洞实现过程</h4><p>攻击者构造恶意链接 -&gt; 用户访问恶意链接 -&gt; 经过Web应用程序和浏览器的解析 -&gt; 跳转到恶意网站</p><p>如果这个网站<code>http://localhost/?url=other.domain</code>的url参数可以用来跳转到其他网页，而网站并没有对 url 参数进行验证、限制的话，那就意味着攻击者也可以通过 url 参数来让用户跳转到任意网站（钓鱼页面、……）。如果是比较知名的公司旗下的网站存在URL跳转漏洞，用户看到恶意链接的域名是属于这个公司的，很可能就会信任这个链接。</p><h4 id="URL跳转漏洞的防御"><a href="#URL跳转漏洞的防御" class="headerlink" title="URL跳转漏洞的防御"></a>URL跳转漏洞的防御</h4><ul><li>严格控制将要跳转的域名</li></ul><h3 id="SQL注入（SQL-Injection）"><a href="#SQL注入（SQL-Injection）" class="headerlink" title="SQL注入（SQL Injection）"></a>SQL注入（SQL Injection）</h3><p>是一种常见的Web安全漏洞，攻击者利用这个漏洞可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>全称是「结构化查询语言（STRUCTURED QUERY LANGUAGE）」，SQL 是用于访问和处理数据库的标准的计算机语言。</p><h4 id="常见的SQL数据库"><a href="#常见的SQL数据库" class="headerlink" title="常见的SQL数据库"></a>常见的SQL数据库</h4><ul><li>MySQL</li><li>SQL Server</li><li>……</li></ul><h4 id="SQL注入基本原理"><a href="#SQL注入基本原理" class="headerlink" title="SQL注入基本原理"></a>SQL注入基本原理</h4><p>以用户登录为例，程序在收到用户名和密码后，往往会先根据用户名和密码在数据库中查询用户名和密码（数据库中一般存储的是密码的Hash值，而不是密码的明文）同时匹配的数据库记录，如果在数据库中查询到对应的数据记录，则登录成功，否则登录失败。<br>它的SQL语句大概是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">'用户名'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">'密码的Hash值'</span><br></code></pre></td></tr></table></figure><p>用户名的值是用户提交的，如果网站没有做相关的过滤的话，就可以提交一些「特殊的用户名」，来达到「修改SQL语句结构，而改变查询」的目的。因为密码字段在数据库中通常是以Hash值存储的，用户提交时程序会将密码转换为对应的Hash值，这样密码的字段就相当于不可控了，就没法通过密码的字段改变SQL语句结构，不过能控制用户名就足够了。在早些年，密码还是以明文存储的，经典的「万能密码」就是通过密码字段的注入点，实现登录任意用户帐号。</p><p>如果将用户名字段写为<code>&#39; or 1=1;--+</code>，那么网站的SQL语句就会变成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">''</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>;<span class="hljs-comment">-- ' and password='密码的Hash值'</span><br></code></pre></td></tr></table></figure><p>可以看到，提交的用户名改变了SQL语句原本的结构，进而改变了它的查询结果，以上语句把验证密码的部分注释掉了，并且使判断语句永远为真，导致的结果就是「会返回数据库中所有的用户数据」（因为判断语句永远为真(or 1=1)，所有数据都会符合判断条件，程序就返回了所有匹配的数据）。SQL注入的本质就是<strong>「数据和代码未分离，把用户输入当作代码执行」</strong>。</p><p>SQL注入需要以下两个必备条件</p><ul><li>可以控制输入的数据</li><li>服务器要执行的代码拼接了控制的数据</li></ul><h4 id="SQL注入点的两种类型"><a href="#SQL注入点的两种类型" class="headerlink" title="SQL注入点的两种类型"></a>SQL注入点的两种类型</h4><ul><li>整数型<br>字段类型为 int ，不需要用引号闭合SQL语句。</li><li>字符型<br>字段类型为 varchar ，字符型注入点则需要进一步判断SQL语句是使用单引号闭合的还是双引号，然后把语句正确闭合。</li></ul><h4 id="SQL注入的挖掘"><a href="#SQL注入的挖掘" class="headerlink" title="SQL注入的挖掘"></a>SQL注入的挖掘</h4><p>只要跟网站数据库有交互的地方都有可能存在SQL注入。（GET参数值、POST参数值、Cookie、……）</p><h5 id="判断是否存在SQL注入"><a href="#判断是否存在SQL注入" class="headerlink" title="判断是否存在SQL注入"></a>判断是否存在SQL注入</h5><p>最常见的是使用<code>and 1=1</code>、<code>and 1=2</code>、<code>&#39;（引号）</code>这几种判断方式。</p><p>假设要判断<code>http://localhost/?id=1</code>的 id 参数是否存在注入，先提交一个引号看看：<code>http://localhost/?id=1%27</code>（%27 是URL编码的单引号，因为无论是字符型还是整数型注入点，输入不成对的单/双引号，都会因为缺少另一半引号而导致SQL语句报错，如果网站报错了，说明 id 参数的值被带入SQL语句中执行了，意味着这里存在SQL注入。</p><h5 id="判断注入点类型"><a href="#判断注入点类型" class="headerlink" title="判断注入点类型"></a>判断注入点类型</h5><p>之所以要判断注入点类型，是因为要知道SQL语句需不需要闭合、用双引号还是单引号闭合，知道这些才能构造正确的SQL语句。如果语句比较复杂，通常会使用注释符（<code>#</code>、<code>--</code>、<code>/**/</code>）来闭合语句末尾。</p><p>找到注入点后，通过提交SQL语句并观察网站变化，来判断注入点是整数型还是字符型（还要判断SQL语句用的是单引号还是双引号）：</p><ul><li><code>http://localhost/?id=1 and 1=1</code> &amp;&amp; <code>http://localhost/?id=1 and 1=2</code></li></ul><p><strong>判断是否为整数型注入</strong></p><p>正常情况下的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>当提交 1=1（第一条测试语句）时的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>逻辑判断为真，所以返回正常。</p><p>当提交 1=2（第二条测试语句）时的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>逻辑判断为假，所以返回错误。</p><p>从外部来看，两次提交返回的结果不一致：1=1 时页面正常，1=2 时返回错误，表明这是整数型注入点。</p><p>当注入点是字符型时，用来判断整数型注入的语句因为没有闭合引号，被引号包裹了，无法改变SQL语句结构，所以不管是 1=1（<code>select * from x where id=&#39;1 and 1=1&#39;</code>）还是 1=2（<code>select * from x where id=&#39;1 and 1=2&#39;</code>）页面都没有变化。</p><p>当页面随着提交的SQL语句不同（1=1、1=2）而改变（页面正常/返回错误）时，就表明当前的测试语句符合注入点的类型（被当作语句执行，改变了逻辑判断的结果），重点就在于页面有没有随着提交的SQL语句的逻辑条件不同而产生变化。这就是使用<code>and 1=1</code>、<code>and 1=2</code>、<code>&#39;（引号）</code>来判断注入点类型的原理。</p><ul><li><code>http://localhost/?id=1&#39; and &#39;1&#39;=&#39;1</code> &amp;&amp; <code>http://localhost/?id=1&#39; and &#39;1&#39;=&#39;2</code></li></ul><p><strong>判断是否是字符型注入（单引号）</strong></p><p>判断注入点类型的原理已经在上面说过了，就不重复说了，只写出各个情况下的SQL语句的变化，可以结合上面说的原理自己思考下。</p><p>正常情况下的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">'1'</span><br></code></pre></td></tr></table></figure><p>当提交 1=1（第一条测试语句） 时的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">'1'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1'</span><br></code></pre></td></tr></table></figure><p>当提交 1=2（第二条测试语句） 时的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> x <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">'1'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'2'</span><br></code></pre></td></tr></table></figure><ul><li><code>http://localhost/?id=1&quot; and &quot;1&quot;=&quot;1</code> &amp;&amp; <code>http://localhost/?id=1&quot; and &quot;1&quot;=&quot;2</code></li></ul><p><strong>双引号的判断方法和上面两位（整数型、单引号）一样，这里不再列举……</strong></p><h5 id="确定查询字段数"><a href="#确定查询字段数" class="headerlink" title="确定查询字段数"></a>确定查询字段数</h5><p><code>order by</code>语句可以用来判断查询的字段数，方便后续构造SQL语句（如：使用 union 时后面的语句的字段数需要和前面语句的查询字段数相同）。<code>http://localhost/?id=1 order by 5 --+</code>中 5 就是我们输入的字段数，如果真实字段数小于我们猜解的字段数就会抛出异常，我们就知道字段数是小于 5 的，然后继续在 1-5 的范围内猜解，逐步缩小范围，直到确定字段数。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/orderby.png" alt="猜解字段数"></p><p>通常会采用「二分查找」的方法来加快猜解的效率：<br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/dichotomy.png" alt="每次选择范围的中间值进行猜解"></p><h5 id="确定回显点"><a href="#确定回显点" class="headerlink" title="确定回显点"></a>确定回显点</h5><p>「回显点」就是各个查询字段显示的位置，SQL语句的返回结果将显示在对应的位置。使用<code>union select</code>语句根据查询字段数指定对应数量的数据（有多少个查询字段，就select 多少个数据，这些数据最好不要相同，更容易分辨）。</p><p>如果有三个查询字段，语句就是这样：<code>http://localhost/?id=1 union select 1,2,3</code>，1、2、3是随便写的，它们会分别显示在对应的回显点，通过看这三个数字在页面的位置，就知道各个查询字段的回显点的位置了。</p><p>union 语句实际上是把两条语句返回的结果合并成一条返回，有些网站程序可能只会读取其中第一条结果，那样后面那条SQL语句返回的结果就没法显示了，这时候就需要让union前面那条语句的返回结果为空，只需要让前面那条语句的条件不成立即可：<code>http://localhost/?id=-1 union select 1,2,3</code>，假设<code>id=-1</code>的数据是不存在的，那返回结果就会为空，而后面那条语句是有结果的，所以最后返回的会是后面那条语句的结果。</p><h4 id="SQL注入的利用"><a href="#SQL注入的利用" class="headerlink" title="SQL注入的利用"></a>SQL注入的利用</h4><h5 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h5><p>常用的MySQL函数：</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">database()</td><td align="center">当前所使用的数据库</td></tr><tr><td align="center">version()</td><td align="center">数据库版本</td></tr><tr><td align="center">user()</td><td align="center">当前用户</td></tr><tr><td align="center">@@datadir</td><td align="center">数据库的存储位置</td></tr><tr><td align="center">@@version_compile_os</td><td align="center">操作系统</td></tr><tr><td align="center">concat()、concat_ws()</td><td align="center">字符串拼接</td></tr><tr><td align="center">ascii()</td><td align="center">返回字符所对应的ASCII码</td></tr><tr><td align="center">substring()、substr()</td><td align="center">字符串截断</td></tr></tbody></table><p>获取信息的常用语句</p><ul><li><p>获取所有数据库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> SCHEMA_NAME <span class="hljs-keyword">from</span> information_schema.SCHEMATA<br></code></pre></td></tr></table></figure></li><li><p>获取指定数据库中的所有表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> TABLE_NAME <span class="hljs-keyword">from</span> information_schema.TABLES <span class="hljs-keyword">where</span> TABLE_SCHEMA=<span class="hljs-keyword">database</span>()<br></code></pre></td></tr></table></figure></li><li><p>获取指定表中所有的字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> COLUMN_NAME <span class="hljs-keyword">from</span> information_schema.COLUMNS <span class="hljs-keyword">where</span> TABLE_NAME=<span class="hljs-string">'USERS'</span><br></code></pre></td></tr></table></figure></li><li><p>获取指定表中，指定字段的所有数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">USERS</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="读取系统文件"><a href="#读取系统文件" class="headerlink" title="读取系统文件"></a>读取系统文件</h5>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">load_file</span>(<span class="hljs-string">'c:\\windows\\win.ini'</span>)<br></code></pre></td></tr></table></figure><p>注：Windows路径需要用双反斜杠转义</p><h5 id="写入WebShell"><a href="#写入WebShell" class="headerlink" title="写入WebShell"></a>写入WebShell</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-string">"&lt;?php @eval($_GET['cmd']); ?&gt;"</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">outfile</span> <span class="hljs-string">'D:\\web\\WWW\\shell.php'</span><br></code></pre></td></tr></table></figure><h4 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h4><p>之前讲的SQL注入实际上都是「SQL回显注入」——数据或执行结果会直接返回到页面上。<br>「SQL盲注」是无法通过SQL注入在页面返回内容中找到所需要的数据或用作注入成功判断的内容，都可以称为SQL盲注。</p><h5 id="SQL盲注的几种方式"><a href="#SQL盲注的几种方式" class="headerlink" title="SQL盲注的几种方式"></a>SQL盲注的几种方式</h5><ul><li>布尔型<br>通过条件判断的方式，观察页面变化来确认执行结果。</li><li>时间型<br>在语句中增加延时函数或者执行比较耗时的命令，通过观察页面加载时间来确认执行结果。</li><li>错误型<br>通过主动引发异常来让数据库将我们想要的信息暴露出来。</li></ul><h5 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h5><p>由于SQL盲注是看不到页面返回结果的，需要通过一步步猜解，才能得到想要的信息。</p><ol><li><p>确定当前数据库名长度<br>这里通过「布尔型」的方法来判断数据库名的长度，语句：<code>id=1 and length(database())&gt;5</code>（省略了前面的域名部分，重点关注 id 参数的值），这里判断数据库名长度是否大于 5，如果条件成立，页面就会正常返回，否则页面就不会正常返回——表明数据库名长度是小于等于 5 的，然后通过「二分查找」的方法接续在 5 的范围内猜解，直到确定数据库名的长度。（「二分查找」实际上更多就是用在进行SQL盲注时的猜解部分）</p></li><li><p>猜当前数据库名</p></li></ol><p>分别猜解数据库名每一位的字符是什么，最终拼凑出完整的数据库名。<br>因为字符无法使用二分查找，猜解效率会非常低（尤其是手工注入的时候），那么可以通过将字符转换为「ASCII码」来解决：<code>select * from users where user_id=1 and ascii(substr(database(),1,1))&gt;100</code>，这里判断当前数据库名的第一个字符的ASCII码是否大于100，不是的话则继续猜解50、25、12……依此类推，最终成功确定数据库名第一个字符的ASCII码，接着只需要查看ASCII码对应的字符是什么即可，然后接着猜下一位字符……最终拼凑出完整的数据库名。之后的「猜表名」、「猜字段名」等，方法都是一样的。</p><p>通过这种方法，可以逐步猜解出想要的信息，初学者应该尽量避免使用工具而使用手工操作，这样可以更好地理解SQL注入并熟练操作。当对SQL注入比较熟悉之后，就可以使用相关工具来解放双手，提高测试效率，开始学习使用「SQL注入神器」<strong>sqlmap</strong>。</p><h4 id="SQL注入的防御"><a href="#SQL注入的防御" class="headerlink" title="SQL注入的防御"></a>SQL注入的防御</h4><ul><li>参数化查询</li><li>强制数据类型</li><li>对用户输入，使用黑/白名单进行验证，把用户输入都当作不可信的</li><li>有一些语言自带安全验证的方法，可以直接调用</li><li>使用外部的安全框架和API</li><li>使用WAF产品（它对Web漏洞是通用的，并不只针对于SQL注入）</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>现在很多网站都有上传功能（上传用户头像、发送文件、……），如果网站没有对用户上传的文件进行严格的验证、过滤的话，就容易产生「文件上传漏洞」，攻击者就可能通过上传恶意文件来将木马植入到网站服务器，从而获取网站权限。</p><h4 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h4><p>一段脚本代码所造成的脚本木马，可以执行攻击者下发的指令，从而控制网站。</p><p>一些语言的一句话木马示例：</p><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST(<span class="hljs-string">"cmd"</span>));<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ul><li>ASP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asp">&lt;%eval request(&quot;cmd&quot;)%&gt;<br></code></pre></td></tr></table></figure><ul><li>ASP.NET</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asp.net">&lt;%@ PageLanguage&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.item[&quot;cmd&quot;], &quot;unsafe&quot;);%&gt;<br></code></pre></td></tr></table></figure><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><p>文件上传功能的实现代码没有严格限制用户上传的文件后缀以及文件类型，导致攻击者可以上传任意文件（当然也包括脚本木马）。</p><h4 id="绕过不同类型的限制，进行文件上传"><a href="#绕过不同类型的限制，进行文件上传" class="headerlink" title="绕过不同类型的限制，进行文件上传"></a>绕过不同类型的限制，进行文件上传</h4><p>大部分程序对于上传的文件都会进行一些限制和过滤的处理，如果程序验证不严谨，就可能被绕过。</p><h5 id="一些绕过程序限制来上传文件的手段"><a href="#一些绕过程序限制来上传文件的手段" class="headerlink" title="一些绕过程序限制来上传文件的手段"></a>一些绕过程序限制来上传文件的手段</h5><ul><li>MiME类型修改<br>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</li><li>文件内容绕过<br>比较常见的是通过将一句话木马插入到图片数据中（图片马），从而绕过Web应用的「文件内容检测」，然后在上传时通过抓包将文件后缀名改为脚本文件的后缀名或者利用「Web容器解析漏洞」来使脚本内容能够成功执行。</li><li>JavaScript 前端绕过<br>有些网站是通过前端的 JavaScript 来验证上传文件的，而 JavaScript 是运行在客户端的，用户是可控的，自然也能被轻易绕过，只需要修改或删除相关的 JavaScript 代码即可（也可以抓包修改文件后缀名）。</li></ul><h3 id="命令、代码执行"><a href="#命令、代码执行" class="headerlink" title="命令、代码执行"></a>命令、代码执行</h3><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数（如 PHP 中的「system」、「exec」、「shell_exec」、……）。</p><p>当用户可以控制命令执行函数中的参数时，就可以注入恶意系统命令到正常的命令中，造成「命令执行漏洞」。</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>当应用在调用一些字符串转化为代码的函数（「eval」、「assert」、「preg_replace」、……）时，没有考虑到用户是否能控制这个字符串内容，将导致「代码注入漏洞」。</p><h4 id="命令、代码执行的防御"><a href="#命令、代码执行的防御" class="headerlink" title="命令、代码执行的防御"></a>命令、代码执行的防御</h4><ul><li><p>尽量少用可以执行命令的的函数（通过在<code>php.ini</code>中的「disable_functions」选项，可以设置要禁用的函数。）</p></li><li><p>使用「escapshellcmd」函数对参数进行过滤</p></li><li><p>在调用命令执行函数之前，对参数进行过滤、对敏感字符进行转义、……</p></li><li><p>避免使用 eval() 来读取 JSON</p></li><li><p>对于必须使用 eval() 的地方，要严格处理用户提交的数据</p></li></ul><h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><p>所有应用程序都是通过逻辑实现各种丰富多彩的功能的，要实现这些功能必须掌握大量的技巧并进行周密的安排i，但在很多情况下，这些功能的逻辑存在缺陷。逻辑缺陷的本质就是<strong>设计者或开发者在思考问题的过程中做出的特殊假设存在明显或隐晦的错误</strong>。</p><p>传统的Web漏洞在找到漏洞点之后，可能需要绕过各种防护手段（安全的开发框架、安全防护软件、入侵检测系统、……）。而「逻辑漏洞」主要是功能逻辑存在缺陷，代码逻辑是人的逻辑思维，找到关键点后，往往不用构造恶意的请求即可完成攻击，很容易绕开防护手段。</p><h4 id="逻辑漏洞常见的表现形式"><a href="#逻辑漏洞常见的表现形式" class="headerlink" title="逻辑漏洞常见的表现形式"></a>逻辑漏洞常见的表现形式</h4><ul><li><p>越权<br>一般包括「水平越权」和「垂直越权」。</p><ul><li><p>水平越权<br>相同级别（权限）的用户（角色）之间，可以越权访问、修改或删除的非法操作。</p><p>如果出现漏洞，将可能会造成大批量数据泄漏，严重的甚至会造成用户信息被恶意篡改。<br>测试方法：一般是在发送请求的数据包中，将请求的资源的唯一标识符（订单ID、用户ID、文章ID、……）修改成一个不属于你的数据，查看返回结果。</p></li><li><p>垂直越权<br>不同级别（或不同角色）之间的越权。</p><ul><li>向上越权<br>低级别（权限）用户可以进行只有高级别用户（管理员）才能做的操作。</li><li>向下越权<br>高级别用户可以访问低级别用户的信息。</li></ul></li></ul></li><li><p>无限制地重试<br>比如在登录的时候，修改数据包中的密码字段重新发送，如果后端没有做次数限制，就会造成「密码爆破漏洞」；如果发送验证码的操作没有做时间限制，那么就会造成「短信轰炸漏洞」。</p></li><li><p>后端信任前端数据</p></li></ul><p>前端是运行在客户端环境下的，意味着数据可能会被伪造，如果后端没有验证前端回传的数据，直接信任了从前端发送来的数据，就可能会被篡改的数据包欺骗。（例如在购买商品时，修改商品的金额，后端没有做验证的话，攻击者就可以任意篡改商品金额，可以想象这个后果有多严重。）</p><ul><li>竞态条件考虑不周<br>竞态条件(race condition)是指设备或系统出现不恰当的执行时序，而得到不正确的结果。<br>一个操作应该只产生一次结果，但是利用多线程重复发送数据包请求，可能产生多条结果。</li><li>……</li></ul>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2019/10/12/%E3%80%8CWeb%E5%AE%89%E5%85%A8%E3%80%8D%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>变态心理学中的各种「心理障碍」</title>
      <link>https://hack1ng4fun.github.io/2019/09/13/%E5%8F%98%E6%80%81%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E3%80%8C%E5%BF%83%E7%90%86%E9%9A%9C%E7%A2%8D%E3%80%8D/</link>
      <guid>https://hack1ng4fun.github.io/2019/09/13/%E5%8F%98%E6%80%81%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E3%80%8C%E5%BF%83%E7%90%86%E9%9A%9C%E7%A2%8D%E3%80%8D/</guid>
      <pubDate>Fri, 13 Sep 2019 05:38:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;变态心理学中的各种「心理障碍」&quot;&gt;&lt;a href=&quot;#变态心理学中的各种「心理障碍」&quot; class=&quot;headerlink&quot; title=&quot;变态心理学中的各种「心理障碍」&quot;&gt;&lt;/a&gt;变态心理学中的各种「心理障碍」&lt;/h1&gt;&lt;p&gt;很多人对于心理障碍的了解是片面或者极端的，这都不利于我们提升自己的心理健康质量，也不利于我们消除对心理障碍的偏见，同时还可能会出现一些误解甚至危害。&lt;br&gt;了解各种心理障碍的症状，一方面增强自己的心理健康意识，另外一方面在身边的人出现一些症状表现时，能够做出正确的应对和反应。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="变态心理学中的各种「心理障碍」"><a href="#变态心理学中的各种「心理障碍」" class="headerlink" title="变态心理学中的各种「心理障碍」"></a>变态心理学中的各种「心理障碍」</h1><p>很多人对于心理障碍的了解是片面或者极端的，这都不利于我们提升自己的心理健康质量，也不利于我们消除对心理障碍的偏见，同时还可能会出现一些误解甚至危害。<br>了解各种心理障碍的症状，一方面增强自己的心理健康意识，另外一方面在身边的人出现一些症状表现时，能够做出正确的应对和反应。</p><a id="more"></a><h2 id="心理疾病和心理问题的区别"><a href="#心理疾病和心理问题的区别" class="headerlink" title="心理疾病和心理问题的区别"></a>心理疾病和心理问题的区别</h2><ul><li><p>三个原则</p><ul><li>幻觉、妄想<br>幻觉：没有发生的事情，看见了、听见了、感觉到了、……<br>妄想：没有发生的事，却坚定地认为它发生了。违背客观事物的存在性，主观地臆断出一些没有发生的事件。</li><li>情绪行为<br>情绪和行为不协调（开心的时候哭，不开心的时候笑……）</li><li>人格稳定性<br>每个人的人格特征，相对来说是稳定的，如果生活中没有出现什么大的挫折、转变的话，人格是趋于稳定的。</li></ul></li><li><p>自知力<br>不知道自己的症状处于一个什么样的状态，否认自己有问题的事实，对自己没有一个客观的判断。</p></li><li><p>求医行为<br>需要的时候，不会想到去求助心理医生(心理咨询师)，没有这个意识。</p></li><li><p>社会功能<br>日常活动被影响，无法正常进行日常活动。</p><ul><li>学习</li><li>工作</li><li>生活</li><li>人际关系</li></ul></li></ul><p><strong>PS:不要轻易地对号入座，从心理问题到心理疾病是个非常复杂的过程。以上所有的指标，即使大部分符合，也只能说明有心理疾病的倾向。如果到了医院，医生还会有更多的考量指标来检测你当前的心理状态和精神状态。</strong></p><h2 id="心理医生和精神科医生的区别"><a href="#心理医生和精神科医生的区别" class="headerlink" title="心理医生和精神科医生的区别"></a>心理医生和精神科医生的区别</h2><ul><li><p>医学背景<br>心理医生(国内更多是称为“心理咨询师”)是各大院校心理学专业背景的，而精神科医生走的是临床医学，是完全独立的另外一条路。虽然两者都会接触到各种心理问题/疾病，但有本质上的区别。</p></li><li><p>处方权<br>国内的心理医生是没有处方权的，即使他受过国外的专业训练，有诊断的能力，知道你可能需要什么药物，他也没有权利告诉你。</p></li><li><p>咨询方法<br>心理医生是通过干预、正确的引导等非临床的手段让来访者的问题减轻或达到恢复的状态。精神科医生可以根据病情进行诊断和开药，只有精神科医生才能明确地告诉你，你患有什么精神疾病，国内的心理医生是不能诊断病情以及开药的。</p></li></ul><h2 id="各种心理障碍"><a href="#各种心理障碍" class="headerlink" title="各种心理障碍"></a>各种心理障碍</h2><ul><li><p>心境障碍</p><ul><li>躁狂<br>持久的情绪高涨，精力、活动的增加，对体力、脑力有非常明显的良好的感觉，说话滔滔不绝，与人过分的亲近，性欲会增强，睡眠减少，幻觉和妄想，易怒，自负(自傲)，行为莽撞……</li><li>双向<br>时而情绪高涨，时而情绪低落，情绪波动大。</li><li>抑郁<br>情绪低落、对任何事物失去兴趣、睡眠障碍、食欲下降、自尊心和自信心非常低、常常会陷入自我否定的状态、……</li></ul></li><li><p>焦虑症</p><ul><li>恐怖型<br>对特定事物的恐惧，如广场、独自坐飞机、公共场合(商场、火车站、……)<br>对人际关系的恐惧，和人接触时会出现脸红、手抖、尿频等生理反应。</li><li>惊恐型<br>会突发地出现心悸，胸闷、心慌、出汗、全身发抖、濒死感、失控感、……</li><li>广泛型<br>长久地、持续地处于紧张不安(持续时间长达三个月以上)的状态，是一种慢性焦虑障碍。</li></ul></li><li><p>强迫症<br>总是被一种强迫思维所困扰，在生活中反复出现强迫观念及强迫行为。自知力完好，知道这样是没有必要的，却无法摆脱。<br>如：反复怀疑手上有细菌，不停地洗手；怀疑房门没锁，反复地确认。</p></li><li><p>创伤后应激障碍<br>经历了重大灾害（严重事故、地震、战争、身受酷刑、……）后引发的心理疾病。当一个人遭受重大创伤后，会本能地回避创伤，拒绝想起和创伤有关的事情，但是创伤却反复地在他们的脑海中闪过、闯入他们的梦境，引发严重的心理疾病，包括社交恐惧症、人格障碍等。</p></li><li><p>人格障碍</p><ul><li><p>偏执型<br>对挫折过分敏感，对侮辱不会轻易原谅，猜疑别人，拒绝批评。会歪曲别人无意的、友好的行为，从而采取敌意和藐视。</p></li><li><p>依赖型<br>没有安全感，特别害怕孤独、被抛弃，渴望得到别人的关爱，过分顺从他人的意志，容忍他人安排自己的生活。有时明知道别人是错误的，为讨别人的喜欢，也要迎合别人。当亲密关系终止时，会感到无助或崩溃。会为了迎合别人而放弃自己的兴趣爱好。</p></li><li><p>焦虑型<br>持久和广泛的内心紧张及忧虑感，不断地渴望被接受，一贯的自我敏感、不安全感及自卑感，习惯夸大生活中潜在的危险因素，达到回避某种活动的程度(无恐惧性的回避)。会因为过分地担心被拒绝，而限定自己的活动范围（如害怕不被接受，而不与人接触）。</p></li><li><p>表演型<br>表现通常夸张、亢奋、活泼，会通过各种手段、行为来吸引别人的注意，非常自我中心，不为他人着想，戏剧化或夸张的情绪表达，认为与他人的关系比实际上的更为亲密，发生在女性身上的比例较高。</p></li></ul></li><li><p>进食障碍</p><ul><li><p>神经性厌食<br>自己有意造成并维持的一种进食障碍，通过限制进食、进食后抠吐、进行过度体育锻炼、滥用减肥药等方法来达到减肥或保持身形苗条的目的。存在对自身体像认知歪曲，尽管与多数人一样，甚至十分消瘦，仍坚持认为自己非常肥胖。对自身胃肠刺激、躯体感受的认知也表现出异常，否认饥饿，否认疲劳感。对体重和体型极度关注，盲目追求苗条。常有营养不良、代谢和内分泌紊乱。</p></li><li><p>神经性贪食<br>反复发作、不可控制、冲动性地暴食，随后采取防止增重的不适当的补偿行为，如禁食、过度运动、诱导呕吐、滥用药物等。</p></li></ul></li><li><p>睡眠障碍</p><ul><li><p>睡眠量的不正常<br>不能入睡、不能够持续睡眠、嗜睡、昏睡等异常状态所导致的睡眠量过长或过短。</p></li><li><p>睡眠中的发作性异常<br>在睡眠中出现如梦游症、梦呓、夜惊、梦魇等一些异常行为</p></li></ul></li><li><p>性功能障碍</p><ul><li><p>性欲障碍<br>缺乏或完全没有进行性行为的欲望或出现性幻想</p></li><li><p>勃起功能障碍<br>阴茎在性行为期间无法勃起或维持勃起</p></li><li><p>早发性射精<br>在伴侣达到性高潮之前射精，或在满意的性行为持续时间之前射精。一般从开始抽插计，少于两分钟即为早发性射精。</p></li><li><p>性高潮障碍<br>经过充分的性刺激和性唤起后，仍然无法或难以达到高潮。</p></li><li><p>性交疼痛障碍<br>性交痛（性交时反复或持续性的阴道疼痛）、阴道痉孪（反复或持续性阴道外1/3平滑肌不自主痉孪性收缩而干扰阴茎的插入）、非接触式性交痛（非直接性交活动引发的生殖器疼痛）。</p></li></ul></li><li><p>精神分裂症<br>精神分裂症的临床症状复杂多样，可涉及感知觉、思维、情感、意志行为及认知功能等方面，个体之间症状差异很大，同一患者在不同阶段或病期也可能表现出不同症状。<br>主要特征是主观体验和客观事实不一致,有严重的幻觉、妄想，时常会感知到不存在的东西，比如听到有人在叫自己名字，甚至会看到不存在的人并且能和它交谈。由于幻觉过于真实（对他们来说），让他们无法清楚分辨现实与幻觉,从而坚定地认为那是真实的。思维紊乱、思考过程缺乏逻辑性和连贯性，言语凌乱，词不达意。此类患者具有一定危险性（可能会有自杀行为）。</p><ul><li>妄想<br>关系妄想、被害妄想、影响妄想、夸大妄想、罪恶妄想、被洞悉感、……等</li><li>幻觉<br>幻听、幻视、幻嗅、幻味、幻触、内脏幻觉……</li></ul></li><li><p>感知障碍</p><ul><li>感觉<br>客观事物的个别属性通过感觉器官在人脑中的反映</li><li>知觉<br>客观事物作用于感觉器官，其各种属性在人脑中经过综合，借助以往经验所形成的一种整体的印象<br>以上两者合称为“感知”，当感知发生异常变化或明显异失常时，统称为感知障碍。</li></ul></li><li><p>物质滥用(精神活性物质滥用)<br>偶尔使用精神活性物质，如果没有对个人身心健康和社会功能产生不良影响，可称为物质使用。当个体反复使用精神活性物质，导致了明显的不良后果，就称为“滥用”。</p><ul><li>毒品依赖<br>鸦片类物质、大麻类物质、可卡因类物质、苯丙胺类物质、致幻剂、催眠镇静药物、抗焦虑药物、……</li></ul></li></ul><hr><p>最后在结尾放几张来自精神分裂症患者的艺术作品，从中或许能大概感受到他们的内心世界。</p><p><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/9s0dfj.png" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/9xcvsm2.png" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/mvwo20f.jpg" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/nv0wje39vb.jpg" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/s9dfjs.jpg" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/v902jlx.jpg" alt="精神分裂症患者的艺术作品"><br><img src="https://raw.githubusercontent.com/Hack1ng4fun/Hack1ng4fun.github.io/Pics/wnermz.jpg" alt="精神分裂症患者的艺术作品"></p>]]></content:encoded>
      
      <comments>https://hack1ng4fun.github.io/2019/09/13/%E5%8F%98%E6%80%81%E5%BF%83%E7%90%86%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E3%80%8C%E5%BF%83%E7%90%86%E9%9A%9C%E7%A2%8D%E3%80%8D/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
